<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã«ã‚ˆã‚‹è½æ›¸ãæŠ½è±¡åŒ–</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="alternate" hreflang="en" href="en.html">
  <link rel="alternate" hreflang="ja" href="index.html">
  <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js"></script>
  <script>
    // è‹±èªãƒ–ãƒ©ã‚¦ã‚¶ã‚’è‹±èªãƒšãƒ¼ã‚¸ã«ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ
    (function() {
      var lang = navigator.language || navigator.userLanguage;
      if (lang && !lang.startsWith('ja') && !sessionStorage.getItem('langRedirected')) {
        sessionStorage.setItem('langRedirected', 'true');
        window.location.href = 'en.html';
      }
    })();
  </script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: 'Arial', sans-serif;
      background-color: #f5f5f5;
      padding: 20px;
    }
    h1 {
      text-align: center;
      color: #333;
      margin-bottom: 20px;
    }
    .container {
      display: flex;
      gap: 20px;
      max-width: 1400px;
      margin: 0 auto;
      background-color: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    @media (max-width: 900px) {
      .container {
        flex-direction: column;
      }
    }
    .left-panel, .right-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    .panel-title {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 10px;
      color: #555;
    }
    canvas {
      border: 2px solid #333;
      border-radius: 5px;
      cursor: crosshair;
      background-color: white;
      max-width: 100%;
      height: auto;
    }
    .controls {
      margin-top: 15px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .control-group {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    label {
      font-weight: bold;
      color: #555;
    }
    input[type="number"] {
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
      width: 100px;
    }
    input[type="checkbox"] {
      width: 18px;
      height: 18px;
    }
    button {
      padding: 10px 20px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      font-size: 14px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    button:hover {
      background-color: #45a049;
    }
    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    button.secondary {
      background-color: #2196F3;
    }
    button.secondary:hover {
      background-color: #0b7dda;
    }
    button.clear {
      background-color: #f44336;
    }
    button.clear:hover {
      background-color: #da190b;
    }
    button.animation {
      background-color: #9C27B0;
    }
    button.animation:hover {
      background-color: #7B1FA2;
    }
    button.share {
      background-color: #FF9800;
    }
    button.share:hover {
      background-color: #F57C00;
    }
    .button-group {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.7);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    .modal-content {
      background-color: white;
      padding: 20px;
      border-radius: 10px;
      max-width: 90%;
      max-height: 90%;
      overflow: auto;
      text-align: center;
    }
    .modal-content h2 {
      margin-bottom: 15px;
      color: #333;
    }
    .modal-content canvas {
      border: 1px solid #ccc;
      cursor: default;
    }
    .modal-buttons {
      margin-top: 15px;
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
    }
    .modal-close {
      background-color: #666;
    }
    .modal-close:hover {
      background-color: #555;
    }
    .status {
      font-size: 14px;
      color: #666;
      padding: 10px;
      background-color: #f0f0f0;
      border-radius: 4px;
      min-height: 40px;
    }
    .progress-container {
      width: 100%;
      height: 20px;
      background-color: #e0e0e0;
      border-radius: 10px;
      overflow: hidden;
      margin-top: 5px;
    }
    .progress-bar {
      height: 100%;
      background-color: #9C27B0;
      width: 0%;
      transition: width 0.1s;
    }
    .mode-info {
      font-size: 12px;
      color: #888;
      margin-top: 5px;
    }
    footer {
      text-align: center;
      margin-top: 20px;
      color: #888;
      font-size: 12px;
    }
    footer a {
      color: #2196F3;
      text-decoration: none;
    }
    footer a:hover {
      text-decoration: underline;
    }
    .lang-switch {
      text-align: right;
      margin-bottom: 10px;
    }
    .lang-switch a {
      color: #2196F3;
      text-decoration: none;
    }
    .qr-hint {
      display: block;
      font-size: 11px;
      color: #666;
      margin-top: 8px;
      line-height: 1.4;
      text-align: center;
    }
    .qr-hint.warning {
      color: #e65100;
    }
    .qr-hint.ok {
      color: #2e7d32;
    }
  </style>
</head>
<body>
  <div class="lang-switch">
    <a href="en.html">ğŸ‡ºğŸ‡¸ English</a>
  </div>
  
  <h1>ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã«ã‚ˆã‚‹è½æ›¸ãæŠ½è±¡åŒ–</h1>
  
  <div class="container">
    <!-- å·¦ãƒ‘ãƒãƒ«: å…¥åŠ› -->
    <div class="left-panel">
      <div class="panel-title">å…¥åŠ›ãƒ‘ãƒ¬ãƒƒãƒˆ</div>
      <canvas id="drawCanvas" width="600" height="400"></canvas>
      
      <div class="controls">
        <div class="control-group">
          <label for="multiStrokeMode">
            <input type="checkbox" id="multiStrokeMode" checked> è¤‡æ•°ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰
          </label>
        </div>
        <div class="mode-info" id="modeInfo">è¤‡æ•°ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰: è¤‡æ•°ã®ç·šã‚’æã‘ã¾ã™ã€‚ç·šã®é–“ã¯è–„ãè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</div>
        
        <div class="control-group">
          <label for="kValue">ãƒ•ãƒ¼ãƒªã‚¨é …æ•° K:</label>
          <input type="number" id="kValue" value="10" min="1" max="1000">
        </div>
        
        <div class="button-group">
          <button id="processBtn">ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›</button>
          <button id="clearBtn" class="clear">ã‚¯ãƒªã‚¢</button>
          <button id="downloadInputBtn" class="secondary">å…¥åŠ›ç”»åƒã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
        </div>
        
        <div class="control-group">
          <label for="numFrames">ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ãƒ¬ãƒ¼ãƒ æ•°:</label>
          <input type="number" id="numFrames" value="30" min="5" max="100">
        </div>
        
        <div class="button-group">
          <button id="animationBtn" class="animation">ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”Ÿæˆ</button>
          <button id="downloadVideoBtn" class="animation" disabled>å‹•ç”»ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
        </div>
      </div>
    </div>
    
    <!-- å³ãƒ‘ãƒãƒ«: å‡ºåŠ› -->
    <div class="right-panel">
      <div class="panel-title">ç”Ÿæˆã•ã‚ŒãŸç”»åƒ</div>
      <canvas id="reconCanvas" width="600" height="400"></canvas>
      
      <div class="controls">
        <div class="status" id="statusText">æç”»ã—ã¦ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„</div>
        <div class="progress-container" id="progressContainer" style="display: none;">
          <div class="progress-bar" id="progressBar"></div>
        </div>
        <div class="button-group">
          <button id="downloadOutputBtn" class="secondary">ç”Ÿæˆç”»åƒã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
          <button id="shareBtn" class="share" disabled>QRã‚«ãƒ¼ãƒ‰ä½œæˆ</button>
        </div>
        <div id="qrHintText" class="qr-hint"></div>
      </div>
    </div>
  </div>
  
  <!-- QRã‚«ãƒ¼ãƒ‰ãƒ¢ãƒ¼ãƒ€ãƒ« -->
  <div id="shareModal" class="modal-overlay">
    <div class="modal-content">
      <h2>ğŸ“œ ã‚¢ãƒ¼ãƒ†ã‚£ãƒ•ã‚¡ã‚¯ãƒˆï¼ˆæ’ä¹…ä¿å­˜ã‚«ãƒ¼ãƒ‰ï¼‰</h2>
      <canvas id="cardCanvas" width="800" height="900"></canvas>
      <div class="modal-buttons">
        <button id="downloadCardBtn" class="secondary">ã‚«ãƒ¼ãƒ‰ç”»åƒã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
        <button id="copyUrlBtn" class="secondary">URLã‚’ã‚³ãƒ”ãƒ¼</button>
        <button id="closeModalBtn" class="modal-close">é–‰ã˜ã‚‹</button>
      </div>
    </div>
  </div>
  
  <footer>
    <p>Created by <a href="https://github.com/milky1210" target="_blank">milky1210</a> | <a href="https://github.com/milky1210/FourierPicture" target="_blank">GitHub</a></p>
    <p>First Published: 2025-11-27 (See <a href="https://github.com/milky1210/FourierPicture/commits/main" target="_blank">git history</a> for precise timestamp)</p>
  </footer>
  
  <script>
    // ============================================
    // FFTå®Ÿè£…ï¼ˆJavaScriptç‰ˆï¼‰
    // ============================================
    
    // è¤‡ç´ æ•°ã‚¯ãƒ©ã‚¹
    class Complex {
      constructor(re, im) {
        this.re = re;
        this.im = im;
      }
      
      add(other) {
        return new Complex(this.re + other.re, this.im + other.im);
      }
      
      sub(other) {
        return new Complex(this.re - other.re, this.im - other.im);
      }
      
      mul(other) {
        return new Complex(
          this.re * other.re - this.im * other.im,
          this.re * other.im + this.im * other.re
        );
      }
      
      scale(s) {
        return new Complex(this.re * s, this.im * s);
      }
      
      abs() {
        return Math.sqrt(this.re * this.re + this.im * this.im);
      }
    }
    
    // DFTï¼ˆé›¢æ•£ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ï¼‰- ä»»æ„ã®é•·ã•ã«å¯¾å¿œ
    function dft(input) {
      const N = input.length;
      const output = [];
      
      for (let k = 0; k < N; k++) {
        let sum = new Complex(0, 0);
        for (let n = 0; n < N; n++) {
          const angle = -2 * Math.PI * k * n / N;
          const exp = new Complex(Math.cos(angle), Math.sin(angle));
          sum = sum.add(input[n].mul(exp));
        }
        output.push(sum);
      }
      
      return output;
    }
    
    // FFTå‘¨æ³¢æ•°é…åˆ—ã‚’ç”Ÿæˆ
    function fftfreq(N) {
      const freqs = [];
      for (let i = 0; i < N; i++) {
        if (i < Math.floor((N + 1) / 2)) {
          freqs.push(i / N);
        } else {
          freqs.push((i - N) / N);
        }
      }
      return freqs;
    }
    
    // 2Dç‰ˆãƒ•ãƒ¼ãƒªã‚¨å†æ§‹æˆ
    function reconstructFourier2d(points, K) {
      const N = points.length;
      if (N === 0) return [];
      
      // è¤‡ç´ æ•°é…åˆ—ã«å¤‰æ›
      const z = points.map(p => new Complex(p[0], p[1]));
      
      // DFTè¨ˆç®—
      const F = dft(z);
      const freqs = fftfreq(N);
      
      // æŒ¯å¹…ã§ã‚½ãƒ¼ãƒˆ
      const amplitudes = F.map(c => c.abs());
      const indices = Array.from({ length: N }, (_, i) => i);
      indices.sort((a, b) => amplitudes[b] - amplitudes[a]);
      
      // ä¸Šä½Kå€‹ã‚’é¸æŠ
      const actualK = Math.min(K, N);
      const selectedIndices = indices.slice(0, actualK);
      
      // å†æ§‹æˆ
      const numOutputPoints = Math.max(N, 200);
      const result = [];
      
      for (let i = 0; i < numOutputPoints; i++) {
        const t = i / numOutputPoints;
        let sum = new Complex(0, 0);
        
        for (const k of selectedIndices) {
          const freq = freqs[k] * N;
          const angle = 2 * Math.PI * freq * t;
          const exp = new Complex(Math.cos(angle), Math.sin(angle));
          sum = sum.add(F[k].scale(1 / N).mul(exp));
        }
        
        result.push([sum.re, sum.im]);
      }
      
      return result;
    }
    
    // 3Dç‰ˆãƒ•ãƒ¼ãƒªã‚¨å†æ§‹æˆï¼ˆx, y, penï¼‰
    function reconstructFourier3d(points, K) {
      const N = points.length;
      if (N === 0) return [];
      
      // å„è»¸ã‚’è¤‡ç´ æ•°é…åˆ—ã«ï¼ˆå®Ÿéƒ¨ã®ã¿ä½¿ç”¨ï¼‰
      const x = points.map(p => new Complex(p[0], 0));
      const y = points.map(p => new Complex(p[1], 0));
      const pen = points.map(p => new Complex(p[2], 0));
      
      // DFTè¨ˆç®—
      const Fx = dft(x);
      const Fy = dft(y);
      const Fpen = dft(pen);
      const freqs = fftfreq(N);
      
      // æŒ¯å¹…ã®åˆè¨ˆã§ã‚½ãƒ¼ãƒˆ
      const amplitudes = [];
      for (let i = 0; i < N; i++) {
        amplitudes.push(Fx[i].abs() + Fy[i].abs() + Fpen[i].abs());
      }
      const indices = Array.from({ length: N }, (_, i) => i);
      indices.sort((a, b) => amplitudes[b] - amplitudes[a]);
      
      // ä¸Šä½Kå€‹ã‚’é¸æŠ
      const actualK = Math.min(K, N);
      const selectedIndices = indices.slice(0, actualK);
      
      // å†æ§‹æˆ
      const numOutputPoints = Math.max(N, 200);
      const result = [];
      
      for (let i = 0; i < numOutputPoints; i++) {
        const t = i / numOutputPoints;
        let sumX = new Complex(0, 0);
        let sumY = new Complex(0, 0);
        let sumPen = new Complex(0, 0);
        
        for (const k of selectedIndices) {
          const freq = freqs[k] * N;
          const angle = 2 * Math.PI * freq * t;
          const exp = new Complex(Math.cos(angle), Math.sin(angle));
          sumX = sumX.add(Fx[k].scale(1 / N).mul(exp));
          sumY = sumY.add(Fy[k].scale(1 / N).mul(exp));
          sumPen = sumPen.add(Fpen[k].scale(1 / N).mul(exp));
        }
        
        // penå€¤ã‚’0-1ã«ã‚¯ãƒªãƒƒãƒ—
        const penVal = Math.max(0, Math.min(1, sumPen.re));
        result.push([sumX.re, sumY.re, penVal]);
      }
      
      return result;
    }
    
    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ãƒ¬ãƒ¼ãƒ ç”Ÿæˆ
    function generateAnimationFrames(points, numFrames, is3d) {
      const N = points.length;
      if (N === 0) return [];
      if (N < 2) return [{ K: N, points: points, isFinal: true }];
      
      const reconstructFn = is3d ? reconstructFourier3d : reconstructFourier2d;
      
      const kMin = 2;
      const kMax = N;
      
      // Kå€¤ã‚’ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
      const kValuesSet = new Set();
      for (let i = 0; i < numFrames; i++) {
        let k;
        if (numFrames === 1) {
          k = kMax;
        } else {
          const t = i / (numFrames - 1);
          const tAdjusted = Math.pow(t, 0.6);
          const logK = Math.log(kMin) + (Math.log(kMax) - Math.log(kMin)) * tAdjusted;
          k = Math.round(Math.exp(logK));
        }
        k = Math.max(kMin, Math.min(k, kMax));
        kValuesSet.add(k);
      }
      
      const kValues = Array.from(kValuesSet).sort((a, b) => a - b);
      
      // ãƒ•ãƒ¬ãƒ¼ãƒ ç”Ÿæˆ
      const frames = [];
      for (const k of kValues) {
        const reconstructed = reconstructFn(points, k);
        frames.push({
          K: k,
          points: reconstructed,
          isFinal: false
        });
      }
      
      // æœ€çµ‚ãƒ•ãƒ¬ãƒ¼ãƒ 
      const finalPoints = reconstructFn(points, N);
      frames.push({
        K: N,
        points: finalPoints,
        isFinal: true
      });
      
      return frames;
    }

    // ============================================
    // ãƒ‡ãƒ¼ã‚¿ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ/ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿèƒ½
    // QRã‚³ãƒ¼ãƒ‰ç”Ÿæˆã«ã¯ qrcode-generator CDN ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨
    // ============================================
    
    // æ•°å€¤ã‚’æŒ‡å®šæ¡ã«ä¸¸ã‚ã‚‹
    function roundNumber(num, decimals) {
      const factor = Math.pow(10, decimals);
      return Math.round(num * factor) / factor;
    }
    
    // ãƒ•ãƒ¼ãƒªã‚¨ä¿‚æ•°ã‚’å–å¾—ï¼ˆå…±æœ‰ç”¨ã«Kå€‹ã«åˆ¶é™ï¼‰
    function getFourierCoefficients(points, K, is3d) {
      const N = points.length;
      if (N === 0) return null;
      
      const actualK = Math.min(K, N);
      
      if (is3d) {
        const x = points.map(p => new Complex(p[0], 0));
        const y = points.map(p => new Complex(p[1], 0));
        const pen = points.map(p => new Complex(p[2], 0));
        
        const Fx = dft(x);
        const Fy = dft(y);
        const Fpen = dft(pen);
        
        // æŒ¯å¹…ã§ã‚½ãƒ¼ãƒˆ
        const amplitudes = [];
        for (let i = 0; i < N; i++) {
          amplitudes.push(Fx[i].abs() + Fy[i].abs() + Fpen[i].abs());
        }
        const indices = Array.from({ length: N }, (_, i) => i);
        indices.sort((a, b) => amplitudes[b] - amplitudes[a]);
        const selectedIndices = indices.slice(0, actualK);
        
        // ä¿‚æ•°ãƒ‡ãƒ¼ã‚¿ï¼ˆRe, Im ã®äº¤äº’é…åˆ—ï¼‰
        const coeffX = [];
        const coeffY = [];
        const coeffPen = [];
        
        for (const k of selectedIndices) {
          coeffX.push(roundNumber(Fx[k].re, 3), roundNumber(Fx[k].im, 3));
          coeffY.push(roundNumber(Fy[k].re, 3), roundNumber(Fy[k].im, 3));
          coeffPen.push(roundNumber(Fpen[k].re, 3), roundNumber(Fpen[k].im, 3));
        }
        
        return {
          f: "v(t)=Sum(Re(Fk*exp(i*2*pi*k*t)))",
          n: N,
          k: selectedIndices.map(i => i),
          d: [coeffX, coeffY, coeffPen]
        };
      } else {
        const z = points.map(p => new Complex(p[0], p[1]));
        const F = dft(z);
        
        const amplitudes = F.map(c => c.abs());
        const indices = Array.from({ length: N }, (_, i) => i);
        indices.sort((a, b) => amplitudes[b] - amplitudes[a]);
        const selectedIndices = indices.slice(0, actualK);
        
        const coeffZ = [];
        for (const k of selectedIndices) {
          coeffZ.push(roundNumber(F[k].re, 3), roundNumber(F[k].im, 3));
        }
        
        return {
          f: "z(t)=Sum(Fk*exp(i*2*pi*k*t))",
          n: N,
          k: selectedIndices.map(i => i),
          d: [coeffZ]
        };
      }
    }
    
    // ä¿‚æ•°ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å†æ§‹æˆ
    function reconstructFromCoefficients(data) {
      const N = data.n;
      const K = data.k;
      const is3d = data.d.length === 3;
      const freqs = fftfreq(N);
      
      const numOutputPoints = Math.max(N, 200);
      const result = [];
      
      if (is3d) {
        const coeffX = data.d[0];
        const coeffY = data.d[1];
        const coeffPen = data.d[2];
        
        for (let i = 0; i < numOutputPoints; i++) {
          const t = i / numOutputPoints;
          let sumX = new Complex(0, 0);
          let sumY = new Complex(0, 0);
          let sumPen = new Complex(0, 0);
          
          for (let j = 0; j < K.length; j++) {
            const k = K[j];
            const freq = freqs[k] * N;
            const angle = 2 * Math.PI * freq * t;
            const exp = new Complex(Math.cos(angle), Math.sin(angle));
            
            const Fxk = new Complex(coeffX[j * 2], coeffX[j * 2 + 1]);
            const Fyk = new Complex(coeffY[j * 2], coeffY[j * 2 + 1]);
            const Fpenk = new Complex(coeffPen[j * 2], coeffPen[j * 2 + 1]);
            
            sumX = sumX.add(Fxk.scale(1 / N).mul(exp));
            sumY = sumY.add(Fyk.scale(1 / N).mul(exp));
            sumPen = sumPen.add(Fpenk.scale(1 / N).mul(exp));
          }
          
          const penVal = Math.max(0, Math.min(1, sumPen.re));
          result.push([sumX.re, sumY.re, penVal]);
        }
      } else {
        const coeffZ = data.d[0];
        
        for (let i = 0; i < numOutputPoints; i++) {
          const t = i / numOutputPoints;
          let sum = new Complex(0, 0);
          
          for (let j = 0; j < K.length; j++) {
            const k = K[j];
            const freq = freqs[k] * N;
            const angle = 2 * Math.PI * freq * t;
            const exp = new Complex(Math.cos(angle), Math.sin(angle));
            
            const Fk = new Complex(coeffZ[j * 2], coeffZ[j * 2 + 1]);
            sum = sum.add(Fk.scale(1 / N).mul(exp));
          }
          
          result.push([sum.re, sum.im]);
        }
      }
      
      return result;
    }
    
    // åŠ¹ç‡çš„ãªãƒã‚¤ãƒŠãƒªã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ï¼ˆä¿‚æ•°ã‚’16bitæ•´æ•°ã«é‡å­åŒ–ï¼‰
    function encodeDataCompact(data) {
      const n = data.n;
      const k = data.k;
      const d = data.d;
      const is3d = d.length === 3;
      
      // ãƒ˜ãƒƒãƒ€ãƒ¼: ãƒãƒ¼ã‚¸ãƒ§ãƒ³(1byte) + ãƒ•ãƒ©ã‚°(1byte) + N(2bytes) + Kæ•°(2bytes)
      const kCount = k.length;
      const headerSize = 6;
      
      // å„ä¿‚æ•°ã®ãƒã‚¤ãƒˆæ•°: ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹(2bytes) + Re(2bytes) + Im(2bytes) = 6bytes per freq
      // 3D: 4bytes(Re+Im) Ã— 3è»¸ = 12bytes per freq, 2D: 4bytes per freq
      const coeffBytesPerFreq = is3d ? 12 : 4;
      const totalBytes = headerSize + kCount * (2 + coeffBytesPerFreq);
      
      const buffer = new ArrayBuffer(totalBytes);
      const view = new DataView(buffer);
      
      let offset = 0;
      view.setUint8(offset++, 2); // version 2 (compact)
      view.setUint8(offset++, is3d ? 1 : 0); // flags
      view.setUint16(offset, n, true); offset += 2;
      view.setUint16(offset, kCount, true); offset += 2;
      
      // ã‚¹ã‚±ãƒ¼ãƒ«ã‚’è¨ˆç®—ï¼ˆä¿‚æ•°ã®æœ€å¤§å€¤ã‚’æ±‚ã‚ã‚‹ï¼‰
      let maxVal = 0;
      for (const arr of d) {
        for (const v of arr) {
          maxVal = Math.max(maxVal, Math.abs(v));
        }
      }
      const scale = maxVal > 0 ? 32000 / maxVal : 1;
      
      // ã‚¹ã‚±ãƒ¼ãƒ«å€¤ã‚’ä¿å­˜ï¼ˆfloat32ã¨ã—ã¦4bytesè¿½åŠ ï¼‰
      const newTotalBytes = totalBytes + 4;
      const newBuffer = new ArrayBuffer(newTotalBytes);
      const newView = new DataView(newBuffer);
      
      // ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ã‚³ãƒ”ãƒ¼
      offset = 0;
      newView.setUint8(offset++, 2);
      newView.setUint8(offset++, is3d ? 1 : 0);
      newView.setUint16(offset, n, true); offset += 2;
      newView.setUint16(offset, kCount, true); offset += 2;
      newView.setFloat32(offset, scale, true); offset += 4;
      
      // ä¿‚æ•°ãƒ‡ãƒ¼ã‚¿
      for (let i = 0; i < kCount; i++) {
        newView.setUint16(offset, k[i], true); offset += 2;
        
        for (let axis = 0; axis < d.length; axis++) {
          const re = Math.round(d[axis][i * 2] * scale);
          const im = Math.round(d[axis][i * 2 + 1] * scale);
          newView.setInt16(offset, re, true); offset += 2;
          newView.setInt16(offset, im, true); offset += 2;
        }
      }
      
      // Uint8Arrayã«å¤‰æ›ã—ã¦Base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰
      const bytes = new Uint8Array(newBuffer);
      const binaryStr = Array.from(bytes, byte => String.fromCharCode(byte)).join('');
      return btoa(binaryStr);
    }
    
    // ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰
    function decodeDataCompact(base64Str) {
      try {
        const binaryStr = atob(base64Str);
        const bytes = new Uint8Array(binaryStr.length);
        for (let i = 0; i < binaryStr.length; i++) {
          bytes[i] = binaryStr.charCodeAt(i);
        }
        const view = new DataView(bytes.buffer);
        
        let offset = 0;
        const version = view.getUint8(offset++);
        const flags = view.getUint8(offset++);
        const n = view.getUint16(offset, true); offset += 2;
        const kCount = view.getUint16(offset, true); offset += 2;
        const scale = view.getFloat32(offset, true); offset += 4;
        
        const is3d = (flags & 1) === 1;
        const k = [];
        const d = is3d ? [[], [], []] : [[]];
        
        for (let i = 0; i < kCount; i++) {
          k.push(view.getUint16(offset, true)); offset += 2;
          
          for (let axis = 0; axis < d.length; axis++) {
            const re = view.getInt16(offset, true) / scale; offset += 2;
            const im = view.getInt16(offset, true) / scale; offset += 2;
            d[axis].push(re, im);
          }
        }
        
        return { n, k, d };
      } catch (e) {
        console.error('Failed to decode compact data:', e);
        return null;
      }
    }
    
    // ãƒ‡ãƒ¼ã‚¿ã‚’Base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ï¼ˆæ—§å½¢å¼ã€äº’æ›æ€§ã®ãŸã‚æ®‹ã™ï¼‰
    function encodeDataToBase64(data) {
      const jsonStr = JSON.stringify(data);
      // UTF-8å¯¾å¿œã®Base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰
      const utf8Bytes = new TextEncoder().encode(jsonStr);
      const binaryStr = Array.from(utf8Bytes, byte => String.fromCharCode(byte)).join('');
      return btoa(binaryStr);
    }
    
    // Base64ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰ï¼ˆè¤‡æ•°å½¢å¼ã«å¯¾å¿œï¼‰
    function decodeDataFromBase64(base64Str) {
      try {
        const binaryStr = atob(base64Str);
        const bytes = new Uint8Array(binaryStr.length);
        for (let i = 0; i < binaryStr.length; i++) {
          bytes[i] = binaryStr.charCodeAt(i);
        }
        
        // æ–°å½¢å¼ï¼ˆASCIIãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ + ãƒã‚¤ãƒŠãƒªï¼‰ã®åˆ¤å®š
        // æœ€åˆã®2ãƒã‚¤ãƒˆãŒASCIIãƒ‡ãƒ¼ã‚¿é•·ã¨ã—ã¦èª­ã‚ã‚‹å ´åˆ
        if (bytes.length > 2) {
          const asciiLen = new DataView(bytes.buffer).getUint16(0, true);
          if (asciiLen < bytes.length && asciiLen < 1000) {
            // ASCIIãƒ‡ãƒ¼ã‚¿éƒ¨ã‚’èª­ã‚€ï¼ˆãŸã ã—æ¤œè¨¼ç”¨ï¼‰
            try {
              const asciiPart = new TextDecoder().decode(bytes.slice(2, 2 + asciiLen));
              if (asciiPart.includes("UNIVERSAL DECODER")) {
                // æ–°å½¢å¼ã¨åˆ¤å®š - ãƒã‚¤ãƒŠãƒªéƒ¨åˆ†ã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰
                const binaryPart = bytes.slice(2 + asciiLen);
                const view = new DataView(binaryPart.buffer, binaryPart.byteOffset);
                let offset = 0;
                
                // ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆå½¢å¼ãƒ‡ã‚³ãƒ¼ãƒ‰
                const version = view.getUint8(offset++);
                if (version === 2) {
                  const flags = view.getUint8(offset++);
                  const n = view.getUint16(offset, true); offset += 2;
                  const kCount = view.getUint16(offset, true); offset += 2;
                  const scale = view.getFloat32(offset, true); offset += 4;
                  
                  const is3d = (flags & 1) === 1;
                  const k = [];
                  const d = is3d ? [[], [], []] : [[]];
                  
                  for (let i = 0; i < kCount; i++) {
                    k.push(view.getUint16(offset, true)); offset += 2;
                    
                    for (let axis = 0; axis < d.length; axis++) {
                      const re = view.getInt16(offset, true) / scale; offset += 2;
                      const im = view.getInt16(offset, true) / scale; offset += 2;
                      d[axis].push(re, im);
                    }
                  }
                  
                  return { n, k, d };
                }
              }
            } catch (e) {
              // ASCIIãƒ‘ãƒ¼ã‚¹å¤±æ•— - æ¬¡ã®æ–¹æ³•ã‚’è©¦ã™
            }
          }
        }
        
        // ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆå½¢å¼ï¼ˆãƒãƒ¼ã‚¸ãƒ§ãƒ³=2ï¼‰ã®åˆ¤å®š
        if (bytes[0] === 2) {
          return decodeDataCompact(base64Str);
        }
        
        // æ—§å½¢å¼ï¼ˆJSONï¼‰
        const jsonStr = new TextDecoder().decode(bytes);
        return JSON.parse(jsonStr);
      } catch (e) {
        console.error('Failed to decode data:', e);
        return null;
      }
    }
    
    // å…±æœ‰URLã‚’ç”Ÿæˆï¼ˆæ–°ã—ã„ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆå½¢å¼ã‚’ä½¿ç”¨ + å¾©å…ƒæ–¹æ³•ã‚’ASCIIåŸ‹ã‚è¾¼ã¿ï¼‰
    function generateShareUrl(coefficients) {
      const encoded = encodeDataCompact(coefficients);
      
      // QRãƒ‡ãƒ¼ã‚¿ã«å¾©å…ƒæ–¹æ³•ã‚’ASCIIå½¢å¼ã§åŸ‹ã‚è¾¼ã¿
      // UNIVERSAL DECODERãƒ˜ãƒƒãƒ€ãƒ¼ + ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿
      const header = "FOURIER:";
      const decoderInfo = "[UNIVERSAL DECODER: FOURIER STROKE]\n" +
                         "Formula: v(t)=Sum(Re(F[k]*exp(i*2*pi*k*t)))\n" +
                         "Range: t=0.0...1.0\n" +
                         "Target: X,Y,Pen axes independently\n" +
                         "Draw: Plot(x(t),y(t)) where pen(t)>0.5\n" +
                         "Data:";
      
      // QRã«ç›´æ¥åŸ‹ã‚è¾¼ã‚ã‚‹å ´åˆã¨ãã†ã§ãªã„å ´åˆã‚’åˆ¤å®š
      // ASCIIãƒ‡ãƒ¼ã‚¿ + ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿ã‚’Base64ã§çµåˆ
      const asciiBytes = new TextEncoder().encode(decoderInfo);
      const binaryBytes = new Uint8Array(atob(encoded).split('').map(c => c.charCodeAt(0)));
      
      // çµåˆ: ASCIIãƒ‡ãƒ¼ã‚¿é•·(2bytes) + ASCIIãƒ‡ãƒ¼ã‚¿ + ãƒã‚¤ãƒŠãƒªãƒ‡ãƒ¼ã‚¿
      const combined = new ArrayBuffer(2 + asciiBytes.length + binaryBytes.length);
      const combinedView = new DataView(combined);
      
      combinedView.setUint16(0, asciiBytes.length, true);
      
      // ASCIIãƒ‡ãƒ¼ã‚¿ã‚’ã‚³ãƒ”ãƒ¼
      const combinedBytes = new Uint8Array(combined);
      combinedBytes.set(asciiBytes, 2);
      combinedBytes.set(binaryBytes, 2 + asciiBytes.length);
      
      // Base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ (Stack overflowå¯¾ç­–)
      let binary = '';
      const len = combinedBytes.byteLength;
      const chunkSize = 0x8000; // 32k
      for (let i = 0; i < len; i += chunkSize) {
        const chunk = combinedBytes.subarray(i, Math.min(i + chunkSize, len));
        binary += String.fromCharCode.apply(null, chunk);
      }
      const finalEncoded = btoa(binary);
      
      const baseUrl = window.location.origin + window.location.pathname;
      return baseUrl + '?d=' + encodeURIComponent(finalEncoded);
    }
    
    // URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿
    function loadFromUrlParams() {
      const urlParams = new URLSearchParams(window.location.search);
      const dataParam = urlParams.get('d');
      
      if (dataParam) {
        try {
          const decoded = decodeDataFromBase64(decodeURIComponent(dataParam));
          if (decoded && decoded.d && decoded.n && decoded.k) {
            return decoded;
          }
        } catch (e) {
          console.error('Failed to load data from URL:', e);
        }
      }
      return null;
    }
    
    // QRã‚³ãƒ¼ãƒ‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¨å®¹é‡ã®å¯¾å¿œè¡¨ï¼ˆèª¤ã‚Šè¨‚æ­£ãƒ¬ãƒ™ãƒ«Mã®å ´åˆã®è‹±æ•°å­—å®¹é‡ï¼‰
    const QR_VERSION_CAPACITY = [
      { version: 1, capacity: 20 },
      { version: 2, capacity: 38 },
      { version: 3, capacity: 61 },
      { version: 4, capacity: 90 },
      { version: 5, capacity: 122 },
      { version: 6, capacity: 154 },
      { version: 7, capacity: 178 },
      { version: 8, capacity: 221 },
      { version: 9, capacity: 262 },
      { version: 10, capacity: 311 },
      { version: 15, capacity: 586 },
      { version: 20, capacity: 969 },
      { version: 25, capacity: 1370 },
      { version: 30, capacity: 1852 },
      { version: 35, capacity: 2324 },
      { version: 40, capacity: 4296 }
    ];
    
    // Kå€¤ã‹ã‚‰ãŠãŠã‚ˆãã®URLé•·ã‚’æ¨å®šï¼ˆã‚³ãƒ³ãƒ‘ã‚¯ãƒˆãƒã‚¤ãƒŠãƒªå½¢å¼ï¼‰
    function estimateUrlLength(k, is3d = true) {
      // ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆå½¢å¼: ãƒ˜ãƒƒãƒ€ãƒ¼10bytes + K * (2 + 4*axes) bytes
      // 3D: 10 + K * (2 + 12) = 10 + 14K bytes
      // 2D: 10 + K * (2 + 4) = 10 + 6K bytes
      const binarySize = is3d ? (10 + k * 14) : (10 + k * 6);
      // Base64ã¯ç´„1.37å€ã€URLã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰ã§ã•ã‚‰ã«å°‘ã—å¢—ãˆã‚‹
      const base64Size = Math.ceil(binarySize * 1.37);
      const baseUrlSize = 80; // ãƒ™ãƒ¼ã‚¹URL + ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å
      return baseUrlSize + base64Size;
    }
    
    // Kå€¤ã«å¯¾ã™ã‚‹QRã‚³ãƒ¼ãƒ‰æƒ…å ±ã‚’å–å¾—
    function getQRInfoForK(k, is3d = true) {
      const estimatedLength = estimateUrlLength(k, is3d);
      
      // ã‚¹ãƒãƒ›ã§èª­ã¿å–ã‚Šã‚„ã™ã„ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ä¸Šé™
      const easyReadMaxVersion = 10; // ãƒãƒ¼ã‚¸ãƒ§ãƒ³10ä»¥ä¸‹ãªã‚‰èª­ã¿å–ã‚Šã‚„ã™ã„
      const possibleMaxVersion = 25; // ãƒãƒ¼ã‚¸ãƒ§ãƒ³25ä»¥ä¸‹ãªã‚‰ä¸€èˆ¬çš„ãªã‚¢ãƒ—ãƒªã§å¯èƒ½
      
      let recommendedVersion = null;
      let isEasyRead = false;
      let isPossible = false;
      
      for (const info of QR_VERSION_CAPACITY) {
        if (estimatedLength <= info.capacity) {
          recommendedVersion = info.version;
          isEasyRead = info.version <= easyReadMaxVersion;
          isPossible = info.version <= possibleMaxVersion;
          break;
        }
      }
      
      return {
        estimatedLength,
        recommendedVersion,
        isEasyRead,
        isPossible,
        maxEasyK: findMaxKForVersion(easyReadMaxVersion, is3d),
        maxPossibleK: findMaxKForVersion(possibleMaxVersion, is3d)
      };
    }
    
    // ç‰¹å®šã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§åã¾ã‚‹æœ€å¤§Kå€¤ã‚’é€†ç®—
    function findMaxKForVersion(maxVersion, is3d = true) {
      const capacity = QR_VERSION_CAPACITY.find(v => v.version >= maxVersion)?.capacity || 4296;
      // é€†ç®—: capacity â‰ˆ 80 + 1.37 * (10 + bytesPerK * k)
      // 3D: bytesPerK = 14, 2D: bytesPerK = 6
      const bytesPerK = is3d ? 14 : 6;
      const maxK = Math.floor(((capacity - 80) / 1.37 - 10) / bytesPerK);
      return Math.max(1, maxK);
    }
    
    // QRã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆã—ã¦Canvasã«æç”»ï¼ˆå¤§ããªKå€¤ã«ã‚‚å¯¾å¿œï¼‰
    function generateQRCode(url, targetCanvas, baseCellSize) {
      try {
        const dataLength = url.length;
        
        // ãƒ‡ãƒ¼ã‚¿é•·ã«å¿œã˜ã¦èª¤ã‚Šè¨‚æ­£ãƒ¬ãƒ™ãƒ«ã¨ã‚»ãƒ«ã‚µã‚¤ã‚ºã‚’èª¿æ•´
        let errorCorrectionLevel = 'M';
        let cellSize = baseCellSize;
        
        // æ®µéšçš„ã«ã‚»ãƒ«ã‚µã‚¤ã‚ºã‚’ç¸®å°ã—ã¦QRã‚³ãƒ¼ãƒ‰ã‚’å°ã•ãã™ã‚‹
        if (dataLength > 500) {
          cellSize = Math.max(4, baseCellSize - 1);
        }
        if (dataLength > 1000) {
          cellSize = Math.max(3, baseCellSize - 2);
          errorCorrectionLevel = 'L'; // å®¹é‡ç¢ºä¿ã®ãŸã‚èª¤ã‚Šè¨‚æ­£ã‚’ä¸‹ã’ã‚‹
        }
        if (dataLength > 2000) {
          cellSize = Math.max(2, baseCellSize - 3);
        }
        if (dataLength > 3000) {
          cellSize = Math.max(1, baseCellSize - 4);
        }
        
        const qr = qrcode(0, errorCorrectionLevel);
        qr.addData(url);
        qr.make();
        
        const ctx = targetCanvas.getContext('2d');
        const moduleCount = qr.getModuleCount();
        const margin = cellSize * 2;
        const size = moduleCount * cellSize + margin * 2;
        
        targetCanvas.width = size;
        targetCanvas.height = size;
        
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, size, size);
        
        for (let row = 0; row < moduleCount; row++) {
          for (let col = 0; col < moduleCount; col++) {
            ctx.fillStyle = qr.isDark(row, col) ? '#000000' : '#ffffff';
            ctx.fillRect(
              col * cellSize + margin,
              row * cellSize + margin,
              cellSize,
              cellSize
            );
          }
        }
        
        return { width: size, height: size, version: Math.ceil((moduleCount - 17) / 4), moduleCount };
      } catch (e) {
        console.error('QR code generation failed:', e);
        return null;
      }
    }
    
    // ç¾åœ¨ã®ä¿‚æ•°ãƒ‡ãƒ¼ã‚¿ï¼ˆå…±æœ‰ç”¨ï¼‰
    let currentCoefficients = null;

    // ============================================
    // UIéƒ¨åˆ†
    // ============================================
    
    // æç”»ã‚­ãƒ£ãƒ³ãƒã‚¹ã®è¨­å®š
    const canvas = document.getElementById('drawCanvas');
    const ctx = canvas.getContext('2d');
    let drawing = false;
    
    // ç‚¹ç¾¤ãƒ‡ãƒ¼ã‚¿
    let currentStroke = [];
    let strokes = [];
    
    // ãƒ¢ãƒ¼ãƒ‰
    let multiStrokeMode = true;

    // å†æ§‹æˆã‚­ãƒ£ãƒ³ãƒã‚¹ã®è¨­å®š
    const reconCanvas = document.getElementById('reconCanvas');
    const rctx = reconCanvas.getContext('2d');
    
    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨
    let animationFrames = [];
    let currentFrameIndex = 0;
    let isPlaying = false;
    let animationId = null;

    // èƒŒæ™¯ã‚’ç™½ã§å¡—ã‚Šã¤ã¶ã™
    function initCanvas(context, canvasElement) {
      context.fillStyle = 'white';
      context.fillRect(0, 0, canvasElement.width, canvasElement.height);
    }

    function updateStatus(text) {
      document.getElementById('statusText').textContent = text;
    }

    function showProgress(show) {
      document.getElementById('progressContainer').style.display = show ? 'block' : 'none';
    }

    function setProgress(percent) {
      document.getElementById('progressBar').style.width = percent + '%';
    }

    // å…¥åŠ›ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’å†æç”»
    function redrawInputCanvas() {
      initCanvas(ctx, canvas);
      
      for (const stroke of strokes) {
        if (stroke.length > 0) {
          ctx.beginPath();
          ctx.moveTo(stroke[0][0], stroke[0][1]);
          for (let i = 1; i < stroke.length; i++) {
            ctx.lineTo(stroke[i][0], stroke[i][1]);
          }
          ctx.strokeStyle = 'black';
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      }
      
      if (currentStroke.length > 0) {
        ctx.beginPath();
        ctx.moveTo(currentStroke[0][0], currentStroke[0][1]);
        for (let i = 1; i < currentStroke.length; i++) {
          ctx.lineTo(currentStroke[i][0], currentStroke[i][1]);
        }
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }

    // 3Dç‚¹ç¾¤ã‚’ç”Ÿæˆ
    function generatePoints3d() {
      const allStrokes = [...strokes];
      if (currentStroke.length > 0) {
        allStrokes.push(currentStroke);
      }
      
      if (allStrokes.length === 0) return [];
      
      const result = [];
      
      for (let s = 0; s < allStrokes.length; s++) {
        const stroke = allStrokes[s];
        
        if (s > 0 && result.length > 0 && stroke.length > 0) {
          const lastPoint = result[result.length - 1];
          const firstPoint = stroke[0];
          
          const numInterp = 10;
          for (let i = 1; i <= numInterp; i++) {
            const t = i / numInterp;
            const x = lastPoint[0] + (firstPoint[0] - lastPoint[0]) * t;
            const y = lastPoint[1] + (firstPoint[1] - lastPoint[1]) * t;
            result.push([x, y, 0]);
          }
        }
        
        for (const pt of stroke) {
          result.push([pt[0], pt[1], 1]);
        }
      }
      
      if (result.length > 0) {
        const lastPoint = result[result.length - 1];
        const firstPoint = result[0];
        
        const numInterp = 10;
        for (let i = 1; i <= numInterp; i++) {
          const t = i / numInterp;
          const x = lastPoint[0] + (firstPoint[0] - lastPoint[0]) * t;
          const y = lastPoint[1] + (firstPoint[1] - lastPoint[1]) * t;
          result.push([x, y, 0]);
        }
      }
      
      return result;
    }

    // 2Dç‚¹ç¾¤ã‚’ç”Ÿæˆ
    function generatePoints2d() {
      const allStrokes = [...strokes];
      if (currentStroke.length > 0) {
        allStrokes.push(currentStroke);
      }
      
      const result = [];
      for (const stroke of allStrokes) {
        for (const pt of stroke) {
          result.push([pt[0], pt[1]]);
        }
      }
      return result;
    }

    initCanvas(ctx, canvas);
    initCanvas(rctx, reconCanvas);

    // ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
    document.getElementById('multiStrokeMode').addEventListener('change', (e) => {
      multiStrokeMode = e.target.checked;
      const modeInfo = document.getElementById('modeInfo');
      if (multiStrokeMode) {
        modeInfo.textContent = 'è¤‡æ•°ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰: è¤‡æ•°ã®ç·šã‚’æã‘ã¾ã™ã€‚ç·šã®é–“ã¯è–„ãè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚';
      } else {
        modeInfo.textContent = 'ä¸€ç­†æ›¸ããƒ¢ãƒ¼ãƒ‰: æããŸã³ã«ãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã™';
      }
    });

    // æç”»ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆãƒã‚¦ã‚¹ï¼‰
    canvas.addEventListener('mousedown', (e) => {
      drawing = true;
      
      if (!multiStrokeMode) {
        strokes = [];
        currentStroke = [];
        initCanvas(ctx, canvas);
      }
      
      currentStroke = [];
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top) * scaleY;
      currentStroke.push([x, y]);
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 2;
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!drawing) return;
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top) * scaleY;
      currentStroke.push([x, y]);
      ctx.lineTo(x, y);
      ctx.stroke();
    });

    canvas.addEventListener('mouseup', () => {
      if (drawing && currentStroke.length > 0) {
        strokes.push([...currentStroke]);
        currentStroke = [];
      }
      drawing = false;
    });

    canvas.addEventListener('mouseleave', () => {
      if (drawing && currentStroke.length > 0) {
        strokes.push([...currentStroke]);
        currentStroke = [];
      }
      drawing = false;
    });

    // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆ
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      drawing = true;
      
      if (!multiStrokeMode) {
        strokes = [];
        currentStroke = [];
        initCanvas(ctx, canvas);
      }
      
      currentStroke = [];
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const touch = e.touches[0];
      const x = (touch.clientX - rect.left) * scaleX;
      const y = (touch.clientY - rect.top) * scaleY;
      currentStroke.push([x, y]);
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 2;
    });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (!drawing) return;
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const touch = e.touches[0];
      const x = (touch.clientX - rect.left) * scaleX;
      const y = (touch.clientY - rect.top) * scaleY;
      currentStroke.push([x, y]);
      ctx.lineTo(x, y);
      ctx.stroke();
    });

    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      if (drawing && currentStroke.length > 0) {
        strokes.push([...currentStroke]);
        currentStroke = [];
      }
      drawing = false;
    });

    // 3Dç‚¹ç¾¤ã‚’æç”»
    const PEN_THRESHOLD = 0.5;
    
    function drawPoints3d(context, canvasEl, pts) {
      initCanvas(context, canvasEl);
      if (pts.length < 2) return;
      
      for (let i = 1; i < pts.length; i++) {
        const x0 = pts[i-1][0];
        const y0 = pts[i-1][1];
        const pen0 = pts[i-1][2];
        const x1 = pts[i][0];
        const y1 = pts[i][1];
        const pen1 = pts[i][2];
        
        const penAvg = (pen0 + pen1) / 2;
        
        if (penAvg < PEN_THRESHOLD) continue;
        
        const alpha = (penAvg - PEN_THRESHOLD) / (1 - PEN_THRESHOLD);
        
        context.beginPath();
        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.strokeStyle = `rgba(255, 0, 0, ${alpha})`;
        context.lineWidth = 2;
        context.stroke();
      }
    }

    // 2Dç‚¹ç¾¤ã‚’æç”»
    function drawPoints2d(context, canvasEl, pts, color = 'red') {
      initCanvas(context, canvasEl);
      if (pts.length > 0) {
        context.beginPath();
        context.moveTo(pts[0][0], pts[0][1]);
        for (let i = 1; i < pts.length; i++) {
          context.lineTo(pts[i][0], pts[i][1]);
        }
        context.strokeStyle = color;
        context.lineWidth = 2;
        context.stroke();
      }
    }

    // ç‚¹ç¾¤ã‚’æç”»
    function drawPoints(context, canvasEl, pts) {
      if (pts.length === 0) return;
      
      if (pts[0].length === 3) {
        drawPoints3d(context, canvasEl, pts);
      } else {
        drawPoints2d(context, canvasEl, pts);
      }
    }

    // QRãƒ’ãƒ³ãƒˆè¡¨ç¤ºã‚’æ›´æ–°ï¼ˆãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›å®Œäº†æ™‚ã«å‘¼ã°ã‚Œã‚‹ï¼‰
    function updateQRHint() {
      const k = parseInt(document.getElementById('kValue').value) || 10;
      const is3d = multiStrokeMode;
      const info = getQRInfoForK(k, is3d);
      const hintText = document.getElementById('qrHintText');
      
      if (info.isEasyRead) {
        hintText.className = 'qr-hint ok';
        hintText.textContent = `ğŸ’¡ K=${k}: QRã‚³ãƒ¼ãƒ‰èª­ã¿å–ã‚Šâ— (Ver.${info.recommendedVersion})`;
      } else if (info.isPossible) {
        hintText.className = 'qr-hint warning';
        hintText.textContent = `ğŸ’¡ K=${k}: QRèª­ã¿å–ã‚Šå¯ã€‚Kâ‰¤${info.maxEasyK}ã§ã‚ˆã‚Šç¢ºå®Ÿã«`;
      } else {
        hintText.className = 'qr-hint warning';
        hintText.textContent = `ğŸ’¡ K=${k}: QRãŒå¤§ã€‚Kâ‰¤${info.maxPossibleK}ã‚’æ¨å¥¨`;
      }
    }

    // ã‚¯ãƒªã‚¢ãƒœã‚¿ãƒ³
    document.getElementById('clearBtn').addEventListener('click', () => {
      strokes = [];
      currentStroke = [];
      animationFrames = [];
      if (animationId) {
        cancelAnimationFrame(animationId);
        clearTimeout(animationId);
        animationId = null;
      }
      isPlaying = false;
      initCanvas(ctx, canvas);
      initCanvas(rctx, reconCanvas);
      document.getElementById('downloadVideoBtn').disabled = true;
      updateStatus('æç”»ã—ã¦ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„');
    });

    // ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ãƒœã‚¿ãƒ³
    document.getElementById('processBtn').addEventListener('click', () => {
      // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’åœæ­¢
      if (animationId) {
        cancelAnimationFrame(animationId);
        clearTimeout(animationId);
        animationId = null;
      }
      isPlaying = false;
      showProgress(false);
      
      const points2d = generatePoints2d();
      const points3d = generatePoints3d();
      
      if (points2d.length === 0) {
        alert("ã¾ãšã¯ã‚­ãƒ£ãƒ³ãƒã‚¹ä¸Šã«æã„ã¦ãã ã•ã„");
        return;
      }
      
      const K = parseInt(document.getElementById('kValue').value);
      if (isNaN(K) || K < 1) {
        alert("K ã®å€¤ã¯1ä»¥ä¸Šã®æ•´æ•°ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
        return;
      }

      updateStatus('å‡¦ç†ä¸­...');
      
      const useMultiStroke = multiStrokeMode;
      const inputPoints = useMultiStroke ? points3d : points2d;
      
      // JavaScriptã§ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã‚’å®Ÿè¡Œ
      setTimeout(() => {
        try {
          let result;
          if (useMultiStroke) {
            result = reconstructFourier3d(inputPoints, K);
          } else {
            result = reconstructFourier2d(inputPoints, K);
          }
          
          drawPoints(rctx, reconCanvas, result);
          const strokeInfo = useMultiStroke ? `, ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯æ•°: ${strokes.length}` : '';
          updateStatus(`ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›å®Œäº† (K=${K}, å…¥åŠ›ç‚¹æ•°: ${inputPoints.length}${strokeInfo})`);
          
          // QRãƒ’ãƒ³ãƒˆã‚’æ›´æ–°
          updateQRHint();
        } catch (error) {
          console.error("Error:", error);
          alert("ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: " + error.message);
          updateStatus('ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
        }
      }, 10);
    });

    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”Ÿæˆãƒœã‚¿ãƒ³
    document.getElementById('animationBtn').addEventListener('click', () => {
      const points2d = generatePoints2d();
      const points3d = generatePoints3d();
      
      if (points2d.length === 0) {
        alert("ã¾ãšã¯ã‚­ãƒ£ãƒ³ãƒã‚¹ä¸Šã«æã„ã¦ãã ã•ã„");
        return;
      }
      
      const numFrames = parseInt(document.getElementById('numFrames').value);
      if (isNaN(numFrames) || numFrames < 5) {
        alert("ãƒ•ãƒ¬ãƒ¼ãƒ æ•°ã¯5ä»¥ä¸Šã®æ•´æ•°ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
        return;
      }

      if (animationId) {
        cancelAnimationFrame(animationId);
        clearTimeout(animationId);
        animationId = null;
      }

      updateStatus('ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆä¸­...');
      showProgress(true);
      setProgress(0);

      const useMultiStroke = multiStrokeMode;
      const inputPoints = useMultiStroke ? points3d : points2d;

      // JavaScriptã§ãƒ•ãƒ¬ãƒ¼ãƒ ç”Ÿæˆ
      setTimeout(() => {
        try {
          animationFrames = generateAnimationFrames(inputPoints, numFrames, useMultiStroke);
          
          if (animationFrames.length === 0) {
            updateStatus('ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“');
            showProgress(false);
            return;
          }
          
          currentFrameIndex = 0;
          isPlaying = true;
          document.getElementById('downloadVideoBtn').disabled = false;
          
          updateStatus(`ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å†ç”Ÿä¸­ (${animationFrames.length}ãƒ•ãƒ¬ãƒ¼ãƒ )`);
          
          playAnimation();
          
        } catch (error) {
          console.error("Error:", error);
          alert("ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: " + error.message);
          updateStatus('ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
          showProgress(false);
        }
      }, 10);
    });

    function playAnimation() {
      if (!isPlaying || animationFrames.length === 0) return;
      
      const frame = animationFrames[currentFrameIndex];
      drawPoints(rctx, reconCanvas, frame.points);
      
      const progress = ((currentFrameIndex + 1) / animationFrames.length) * 100;
      setProgress(progress);
      
      if (frame.isFinal) {
        updateStatus(`å®Œæˆï¼ K = ${frame.K} (å…¨æˆåˆ†)`);
      } else {
        updateStatus(`K = ${frame.K} (ãƒ•ãƒ¬ãƒ¼ãƒ  ${currentFrameIndex + 1}/${animationFrames.length})`);
      }
      
      currentFrameIndex++;
      if (currentFrameIndex >= animationFrames.length) {
        currentFrameIndex = 0;
      }
      
      const delay = frame.isFinal ? 3000 : 100;
      
      animationId = setTimeout(() => {
        requestAnimationFrame(playAnimation);
      }, delay);
    }

    // å‹•ç”»ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³
    document.getElementById('downloadVideoBtn').addEventListener('click', async () => {
      if (animationFrames.length === 0) {
        alert("ã¾ãšã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„");
        return;
      }

      isPlaying = false;
      if (animationId) {
        cancelAnimationFrame(animationId);
        clearTimeout(animationId);
        animationId = null;
      }

      updateStatus('å‹•ç”»ã‚’ç”Ÿæˆä¸­...');
      showProgress(true);
      setProgress(0);

      try {
        const stream = reconCanvas.captureStream(30);
        const mediaRecorder = new MediaRecorder(stream, {
          mimeType: 'video/webm;codecs=vp9',
          videoBitsPerSecond: 5000000
        });
        
        const chunks = [];
        mediaRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) {
            chunks.push(e.data);
          }
        };
        
        mediaRecorder.onstop = () => {
          const blob = new Blob(chunks, { type: 'video/webm' });
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = 'fourier_animation.webm';
          link.click();
          URL.revokeObjectURL(url);
          
          updateStatus('å‹•ç”»ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãŒå®Œäº†ã—ã¾ã—ãŸ');
          showProgress(false);
          
          isPlaying = true;
          playAnimation();
        };

        mediaRecorder.start();
        
        for (let i = 0; i < animationFrames.length; i++) {
          const frame = animationFrames[i];
          drawPoints(rctx, reconCanvas, frame.points);
          setProgress(((i + 1) / animationFrames.length) * 100);
          
          const delay = frame.isFinal ? 3000 : 100;
          await new Promise(resolve => setTimeout(resolve, delay));
        }
        
        mediaRecorder.stop();
        
      } catch (error) {
        console.error("Error:", error);
        
        alert("å‹•ç”»ç”Ÿæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ãƒ–ãƒ©ã‚¦ã‚¶ãŒWebMå½¢å¼ã«å¯¾å¿œã—ã¦ã„ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚");
        updateStatus('å‹•ç”»ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ');
        showProgress(false);
        
        isPlaying = true;
        playAnimation();
      }
    });

    // å…¥åŠ›ç”»åƒãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
    document.getElementById('downloadInputBtn').addEventListener('click', () => {
      const link = document.createElement('a');
      link.download = 'input_image.png';
      link.href = canvas.toDataURL('image/png');
      link.click();
    });

    // ç”Ÿæˆç”»åƒãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
    document.getElementById('downloadOutputBtn').addEventListener('click', () => {
      const link = document.createElement('a');
      link.download = 'fourier_image.png';
      link.href = reconCanvas.toDataURL('image/png');
      link.click();
    });

    // ============================================
    // QRã‚«ãƒ¼ãƒ‰ç”Ÿæˆãƒ»å…±æœ‰æ©Ÿèƒ½
    // ============================================
    
    const shareModal = document.getElementById('shareModal');
    const cardCanvas = document.getElementById('cardCanvas');
    const cardCtx = cardCanvas.getContext('2d');
    let currentShareUrl = '';
    
    // QRã‚«ãƒ¼ãƒ‰ç”»åƒã‚’ç”Ÿæˆ
    function generateArtifactCard(artCanvas, coefficients) {
      try {
        const shareUrl = generateShareUrl(coefficients);
        currentShareUrl = shareUrl;
        
        // ã‚«ãƒ¼ãƒ‰å¹…ã¯å›ºå®š
        const cardWidth = 800;
        const margin = 30;
        const artSize = 500;
        
        // ã‚¢ãƒ¼ãƒˆç”»åƒã®é«˜ã•è¨ˆç®—
        const artHeight = artSize * (artCanvas.height / artCanvas.width);
        const artX = (cardWidth - artSize) / 2;
        const artY = margin + 50;
        
        // QRã‚³ãƒ¼ãƒ‰ç”Ÿæˆï¼ˆã‚µã‚¤ã‚ºè¨ˆæ¸¬ã®ãŸã‚å…ˆã«å®Ÿè¡Œï¼‰
        const tempQrCanvas = document.createElement('canvas');
        const qrResult = generateQRCode(shareUrl, tempQrCanvas, 6);
        
        // URLé•·ã®è­¦å‘Š
        if (shareUrl.length > 2000) {
          console.warn('Share URL is ' + shareUrl.length + ' characters. QR code may be hard to scan. Try reducing K value.');
        }
        
        // QRé…ç½®ã¨ã‚µã‚¤ã‚ºã®è¨ˆç®—
        let qrX, qrY, qrDisplaySize = 0;
        let qrBottom = artY + artHeight + 20; // QRãŒãªã„å ´åˆã®é–‹å§‹ä½ç½®
        
        if (qrResult) {
          const maxQrDisplaySize = 250;
          qrDisplaySize = Math.min(maxQrDisplaySize, qrResult.width);
          
          if (qrDisplaySize > 200) {
            // å¤§ãã„QRã¯ä¸‹éƒ¨ä¸­å¤®ã«é…ç½®
            qrX = (cardWidth - qrDisplaySize) / 2;
            qrY = artY + artHeight + 40;
          } else {
            // å°ã•ã„QRã¯å³ä¸‹ã«é…ç½®
            qrX = cardWidth - margin - qrDisplaySize;
            qrY = artY + artHeight + 30;
          }
          
          // QRã®ä¸‹ã«ãƒ†ã‚­ã‚¹ãƒˆãŒå…¥ã‚‹åˆ†ã®ãƒãƒ¼ã‚¸ãƒ³
          qrBottom = qrY + qrDisplaySize + 40;
        } else {
          // QRç”Ÿæˆå¤±æ•—æ™‚ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆï¼ˆã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç”¨ã®ã‚¹ãƒšãƒ¼ã‚¹ç¢ºä¿ï¼‰
          qrBottom = artY + artHeight + 100;
        }
        
        // Rosetta Textã®å†…å®¹æº–å‚™
        const rosettaLines = [
          'Format: IDFT (Real part only) of X, Y, Pen',
          'Formula: v(t) = (1/N) * Î£ Re(Fk * exp(i*2*Ï€*k*t))',
          '',
          'Data structure: { n: N, k: [indices], d: [coeffs] }',
          '  - N: Original point count',
          '  - k: Selected frequency indices (sorted by amplitude)',
          '  - d: [X coeffs, Y coeffs, Pen coeffs]',
          '       Each: [Re0, Im0, Re1, Im1, ...]',
          '',
          'To reconstruct:',
          '  1. Decode Base64 from URL parameter "d"',
          '  2. Parse JSON to get {n, k, d}',
          '  3. For t âˆˆ [0,1), compute:',
          '     x(t) = Î£ Re(Fxk * exp(i*2*Ï€*fk*N*t)) / N',
          '     y(t) = Î£ Re(Fyk * exp(i*2*Ï€*fk*N*t)) / N',
          '     pen(t) = clamp(Î£ Re(Fpenk * ...) / N, 0, 1)',
          '  4. Draw line when pen(t) > 0.5',
          '',
          `K = ${coefficients.k.length}, N = ${coefficients.n}`
        ];
        
        // Rosetta Textã®é…ç½®è¨ˆç®—
        const rosettaY = qrBottom + 30;
        const rosettaLineHeight = 16;
        const rosettaHeight = rosettaLines.length * rosettaLineHeight;
        
        // å¿…è¦ãªã‚«ãƒ¼ãƒ‰ã®é«˜ã•ã‚’è¨ˆç®— (ãƒ•ãƒƒã‚¿ãƒ¼åˆ† 50px + ãƒãƒ¼ã‚¸ãƒ³)
        const cardHeight = rosettaY + rosettaHeight + 60;
        
        // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚µã‚¤ã‚ºæ›´æ–°
        cardCanvas.width = cardWidth;
        cardCanvas.height = cardHeight;
        
        // èƒŒæ™¯
        cardCtx.fillStyle = '#ffffff';
        cardCtx.fillRect(0, 0, cardWidth, cardHeight);
        
        // ã‚¿ã‚¤ãƒˆãƒ«
        cardCtx.fillStyle = '#333333';
        cardCtx.font = 'bold 24px Arial, sans-serif';
        cardCtx.textAlign = 'center';
        cardCtx.fillText('Fourier Art Artifact', cardWidth / 2, margin + 25);
        
        // æ ç·š
        cardCtx.strokeStyle = '#333333';
        cardCtx.lineWidth = 2;
        cardCtx.strokeRect(artX - 2, artY - 2, artSize + 4, artHeight + 4);
        
        // ã‚¢ãƒ¼ãƒˆç”»åƒæç”»
        cardCtx.drawImage(artCanvas, artX, artY, artSize, artHeight);
        
        // QRã‚³ãƒ¼ãƒ‰æç”»
        if (qrResult) {
          cardCtx.drawImage(tempQrCanvas, qrX, qrY, qrDisplaySize, qrDisplaySize);
          
          // QRãƒ©ãƒ™ãƒ«
          cardCtx.fillStyle = '#666666';
          cardCtx.font = '12px Arial, sans-serif';
          cardCtx.textAlign = 'center';
          cardCtx.fillText('Scan to restore', qrX + qrDisplaySize / 2, qrY + qrDisplaySize + 15);
          
          // QRæƒ…å ±è¡¨ç¤º
          cardCtx.fillStyle = '#999999';
          cardCtx.font = '10px Arial, sans-serif';
          cardCtx.fillText(`QR Ver.${qrResult.version}`, qrX + qrDisplaySize / 2, qrY + qrDisplaySize + 28);
        } else {
          // QRç”Ÿæˆå¤±æ•—æ™‚ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
          cardCtx.fillStyle = '#cc0000';
          cardCtx.font = 'bold 14px Arial, sans-serif';
          cardCtx.textAlign = 'center';
          cardCtx.fillText('QR Code generation failed (Data too large)', cardWidth / 2, artY + artHeight + 50);
          cardCtx.fillStyle = '#666666';
          cardCtx.font = '12px Arial, sans-serif';
          cardCtx.fillText('URL is valid but too long for QR code.', cardWidth / 2, artY + artHeight + 70);
        }
        
        // Rosetta Textæç”»
        const rosettaX = margin;
        
        cardCtx.fillStyle = '#333333';
        cardCtx.font = 'bold 14px monospace';
        cardCtx.textAlign = 'left';
        cardCtx.fillText('=== ROSETTA STONE FOR FUTURE ===', rosettaX, rosettaY);
        
        cardCtx.font = '12px monospace';
        cardCtx.fillStyle = '#555555';
        
        let lineY = rosettaY + 20;
        for (const line of rosettaLines) {
          cardCtx.fillText(line, rosettaX, lineY);
          lineY += rosettaLineHeight;
        }
        
        // ãƒ•ãƒƒã‚¿ãƒ¼
        cardCtx.fillStyle = '#888888';
        cardCtx.font = '10px Arial, sans-serif';
        cardCtx.textAlign = 'center';
        cardCtx.fillText('Generated by FourierPicture | github.com/milky1210/FourierPicture', cardWidth / 2, cardHeight - 15);
        cardCtx.fillText(`Created: ${new Date().toISOString().split('T')[0]}`, cardWidth / 2, cardHeight - 30);
        
        return shareUrl;
      } catch (e) {
        console.error("Error generating artifact card:", e);
        alert("ã‚«ãƒ¼ãƒ‰ç”Ÿæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: " + e.message);
        return null;
      }
    }
    
    // QRã‚«ãƒ¼ãƒ‰ä½œæˆãƒœã‚¿ãƒ³
    document.getElementById('shareBtn').addEventListener('click', () => {
      if (!currentCoefficients) {
        alert('ã¾ãšãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„');
        return;
      }
      
      generateArtifactCard(reconCanvas, currentCoefficients);
      shareModal.style.display = 'flex';
    });
    
    // ã‚«ãƒ¼ãƒ‰ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
    document.getElementById('downloadCardBtn').addEventListener('click', () => {
      const link = document.createElement('a');
      link.download = 'fourier_artifact_card.png';
      link.href = cardCanvas.toDataURL('image/png');
      link.click();
    });
    
    // URLã‚³ãƒ”ãƒ¼
    document.getElementById('copyUrlBtn').addEventListener('click', async () => {
      if (currentShareUrl) {
        try {
          await navigator.clipboard.writeText(currentShareUrl);
          alert('URLã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ');
        } catch (e) {
          // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
          const textArea = document.createElement('textarea');
          textArea.value = currentShareUrl;
          document.body.appendChild(textArea);
          textArea.select();
          document.execCommand('copy');
          document.body.removeChild(textArea);
          alert('URLã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ');
        }
      }
    });
    
    // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
    document.getElementById('closeModalBtn').addEventListener('click', () => {
      shareModal.style.display = 'none';
    });
    
    // ãƒ¢ãƒ¼ãƒ€ãƒ«å¤–ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
    shareModal.addEventListener('click', (e) => {
      if (e.target === shareModal) {
        shareModal.style.display = 'none';
      }
    });
    
    // ============================================
    // URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰ã®å¾©å…ƒï¼ˆãƒ“ãƒ¥ãƒ¼ã‚¢ãƒ¼ãƒ¢ãƒ¼ãƒ‰ï¼‰
    // ============================================
    
    // å…±æœ‰ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ç”Ÿæˆ
    function generateAnimationFramesFromCoefficients(data, numFrames) {
      const K = data.k.length;
      const is3d = data.d.length === 3;
      
      if (K === 0) return [];
      if (K < 2) {
        const points = reconstructFromCoefficients(data);
        return [{ K: K, points: points, isFinal: true }];
      }
      
      const kMin = 2;
      const kMax = K;
      
      const kValuesSet = new Set();
      for (let i = 0; i < numFrames; i++) {
        let k;
        if (numFrames === 1) {
          k = kMax;
        } else {
          const t = i / (numFrames - 1);
          const tAdjusted = Math.pow(t, 0.6);
          const logK = Math.log(kMin) + (Math.log(kMax) - Math.log(kMin)) * tAdjusted;
          k = Math.round(Math.exp(logK));
        }
        k = Math.max(kMin, Math.min(k, kMax));
        kValuesSet.add(k);
      }
      
      const kValues = Array.from(kValuesSet).sort((a, b) => a - b);
      
      const frames = [];
      for (const k of kValues) {
        // kå€‹ã®ä¿‚æ•°ã ã‘ã‚’ä½¿ç”¨
        const partialData = {
          f: data.f,
          n: data.n,
          k: data.k.slice(0, k),
          d: data.d.map(arr => arr.slice(0, k * 2))
        };
        const reconstructed = reconstructFromCoefficients(partialData);
        frames.push({
          K: k,
          points: reconstructed,
          isFinal: false
        });
      }
      
      // æœ€çµ‚ãƒ•ãƒ¬ãƒ¼ãƒ ï¼ˆå…¨ä¿‚æ•°ä½¿ç”¨ï¼‰
      const finalPoints = reconstructFromCoefficients(data);
      frames.push({
        K: K,
        points: finalPoints,
        isFinal: true
      });
      
      return frames;
    }
    
    // ãƒ“ãƒ¥ãƒ¼ã‚¢ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã®åˆæœŸåŒ–
    function initViewerMode(data) {
      const is3d = data.d.length === 3;
      
      // å·¦ãƒ‘ãƒãƒ«ã‚’éè¡¨ç¤ºã«ã—ã€å³ãƒ‘ãƒãƒ«ã‚’æ‹¡å¤§
      document.querySelector('.left-panel').style.display = 'none';
      document.querySelector('.right-panel').style.flex = '1';
      document.querySelector('.right-panel .panel-title').textContent = 'å…±æœ‰ã•ã‚ŒãŸãƒ•ãƒ¼ãƒªã‚¨ã‚¢ãƒ¼ãƒˆ';
      
      // ãƒœã‚¿ãƒ³ã®è¡¨ç¤ºã‚’å¤‰æ›´
      document.getElementById('shareBtn').style.display = 'none';
      
      // æ–°ã—ã„ãƒœã‚¿ãƒ³ã‚’è¿½åŠ 
      const buttonGroup = document.querySelector('.right-panel .button-group');
      
      // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å†ç”Ÿãƒœã‚¿ãƒ³
      const playBtn = document.createElement('button');
      playBtn.id = 'viewerPlayBtn';
      playBtn.className = 'animation';
      playBtn.textContent = 'ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å†ç”Ÿ';
      buttonGroup.appendChild(playBtn);
      
      // å‹•ç”»ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³
      const videoBtn = document.createElement('button');
      videoBtn.id = 'viewerVideoBtn';
      videoBtn.className = 'animation';
      videoBtn.textContent = 'å‹•ç”»ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰';
      videoBtn.disabled = true;
      buttonGroup.appendChild(videoBtn);
      
      // æ–°è¦ä½œæˆãƒªãƒ³ã‚¯
      const newBtn = document.createElement('button');
      newBtn.className = 'secondary';
      newBtn.textContent = 'æ–°è¦ä½œæˆ';
      newBtn.addEventListener('click', () => {
        window.location.href = window.location.pathname;
      });
      buttonGroup.appendChild(newBtn);
      
      // åˆæœŸæç”»
      const points = reconstructFromCoefficients(data);
      drawPoints(rctx, reconCanvas, points);
      updateStatus(`å¾©å…ƒå®Œäº† (K=${data.k.length}, N=${data.n})`);
      
      // ä¿‚æ•°ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ï¼ˆQRã‚«ãƒ¼ãƒ‰ç”Ÿæˆç”¨ - ãƒ“ãƒ¥ãƒ¼ã‚¢ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã§ã¯ä½¿ç”¨ã—ãªã„ï¼‰
      currentCoefficients = data;
      
      // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å†ç”Ÿ
      playBtn.addEventListener('click', () => {
        if (animationId) {
          cancelAnimationFrame(animationId);
          clearTimeout(animationId);
          animationId = null;
        }
        
        animationFrames = generateAnimationFramesFromCoefficients(data, 30);
        
        if (animationFrames.length === 0) {
          updateStatus('ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“');
          return;
        }
        
        currentFrameIndex = 0;
        isPlaying = true;
        videoBtn.disabled = false;
        
        showProgress(true);
        updateStatus(`ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å†ç”Ÿä¸­ (${animationFrames.length}ãƒ•ãƒ¬ãƒ¼ãƒ )`);
        playAnimation();
      });
      
      // å‹•ç”»ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
      videoBtn.addEventListener('click', async () => {
        if (animationFrames.length === 0) {
          // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒæœªç”Ÿæˆã®å ´åˆã¯ç”Ÿæˆ
          animationFrames = generateAnimationFramesFromCoefficients(data, 30);
        }
        
        if (animationFrames.length === 0) {
          alert('ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“');
          return;
        }
        
        isPlaying = false;
        if (animationId) {
          cancelAnimationFrame(animationId);
          clearTimeout(animationId);
          animationId = null;
        }
        
        updateStatus('å‹•ç”»ã‚’ç”Ÿæˆä¸­...');
        showProgress(true);
        setProgress(0);
        
        try {
          const stream = reconCanvas.captureStream(30);
          const mediaRecorder = new MediaRecorder(stream, {
            mimeType: 'video/webm;codecs=vp9',
            videoBitsPerSecond: 5000000
          });
          
          const chunks = [];
          mediaRecorder.ondataavailable = (e) => {
            if (e.data.size > 0) {
              chunks.push(e.data);
            }
          };
          
          mediaRecorder.onstop = () => {
            const blob = new Blob(chunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'fourier_animation.webm';
            link.click();
            URL.revokeObjectURL(url);
            
            updateStatus('å‹•ç”»ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãŒå®Œäº†ã—ã¾ã—ãŸ');
            showProgress(false);
            
            // æœ€çµ‚ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’è¡¨ç¤º
            const finalPoints = reconstructFromCoefficients(data);
            drawPoints(rctx, reconCanvas, finalPoints);
          };
          
          mediaRecorder.start();
          
          for (let i = 0; i < animationFrames.length; i++) {
            const frame = animationFrames[i];
            drawPoints(rctx, reconCanvas, frame.points);
            setProgress(((i + 1) / animationFrames.length) * 100);
            
            const delay = frame.isFinal ? 3000 : 100;
            await new Promise(resolve => setTimeout(resolve, delay));
          }
          
          mediaRecorder.stop();
          
        } catch (error) {
          console.error("Error:", error);
          alert("å‹•ç”»ç”Ÿæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ãƒ–ãƒ©ã‚¦ã‚¶ãŒWebMå½¢å¼ã«å¯¾å¿œã—ã¦ã„ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚");
          updateStatus('å‹•ç”»ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ');
          showProgress(false);
        }
      });
    }
    
    // ============================================
    // åˆæœŸåŒ–
    // ============================================
    
    // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ãƒã‚§ãƒƒã‚¯
    window.addEventListener('load', () => {
      const sharedData = loadFromUrlParams();
      
      if (sharedData) {
        // ãƒ“ãƒ¥ãƒ¼ã‚¢ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã§èµ·å‹•
        initViewerMode(sharedData);
      } else {
        // é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ - shareãƒœã‚¿ãƒ³ã¯å¤‰æ›å¾Œã«æœ‰åŠ¹åŒ–
        document.getElementById('shareBtn').disabled = true;
      }
    });
    
    // ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›æ™‚ã«ä¿‚æ•°ã‚’ä¿å­˜
    document.getElementById('processBtn').addEventListener('click', () => {
      // ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›å®Ÿè¡Œå¾Œã«ä¿‚æ•°ã‚’è¨ˆç®—
      setTimeout(() => {
        const points3d = generatePoints3d();
        const points2d = generatePoints2d();
        
        if (points2d.length > 0) {
          const K = parseInt(document.getElementById('kValue').value);
          const useMultiStroke = multiStrokeMode;
          const inputPoints = useMultiStroke ? points3d : points2d;
          
          // å…±æœ‰ç”¨ã®ä¿‚æ•°ã‚’å–å¾—ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼æŒ‡å®šã®Kã‚’ä½¿ç”¨ï¼‰
          const shareK = K;
          currentCoefficients = getFourierCoefficients(inputPoints, shareK, useMultiStroke);
          
          // shareãƒœã‚¿ãƒ³ã‚’æœ‰åŠ¹åŒ–
          document.getElementById('shareBtn').disabled = false;
        }
      }, 100);
    });
  </script>
</body>
</html>
