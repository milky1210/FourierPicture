<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã«ã‚ˆã‚‹è½æ›¸ãæŠ½è±¡åŒ–</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="alternate" hreflang="en" href="en.html">
  <link rel="alternate" hreflang="ja" href="index.html">
  <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js"></script>
  <script>
    // è‹±èªãƒ–ãƒ©ã‚¦ã‚¶ã‚’è‹±èªãƒšãƒ¼ã‚¸ã«ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆ
    (function() {
      var lang = navigator.language || navigator.userLanguage;
      if (lang && !lang.startsWith('ja') && !sessionStorage.getItem('langRedirected')) {
        sessionStorage.setItem('langRedirected', 'true');
        window.location.href = 'en.html';
      }
    })();
  </script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: 'Arial', sans-serif;
      background-color: #f5f5f5;
      padding: 20px;
    }
    h1 {
      text-align: center;
      color: #333;
      margin-bottom: 20px;
    }
    .container {
      display: flex;
      gap: 20px;
      max-width: 1400px;
      margin: 0 auto;
      background-color: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    @media (max-width: 900px) {
      .container {
        flex-direction: column;
      }
    }
    .left-panel, .right-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    .panel-title {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 10px;
      color: #555;
    }
    canvas {
      border: 2px solid #333;
      border-radius: 5px;
      cursor: crosshair;
      background-color: white;
      max-width: 100%;
      height: auto;
    }
    .controls {
      margin-top: 15px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .control-group {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    label {
      font-weight: bold;
      color: #555;
    }
    input[type="number"] {
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
      width: 100px;
    }
    input[type="checkbox"] {
      width: 18px;
      height: 18px;
    }
    button {
      padding: 10px 20px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      font-size: 14px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    button:hover {
      background-color: #45a049;
    }
    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    button.secondary {
      background-color: #2196F3;
    }
    button.secondary:hover {
      background-color: #0b7dda;
    }
    button.clear {
      background-color: #f44336;
    }
    button.clear:hover {
      background-color: #da190b;
    }
    button.animation {
      background-color: #9C27B0;
    }
    button.animation:hover {
      background-color: #7B1FA2;
    }
    button.share {
      background-color: #FF9800;
    }
    button.share:hover {
      background-color: #F57C00;
    }
    .button-group {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.7);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    .modal-content {
      background-color: white;
      padding: 20px;
      border-radius: 10px;
      max-width: 90%;
      max-height: 90%;
      overflow: auto;
      text-align: center;
    }
    .modal-content h2 {
      margin-bottom: 15px;
      color: #333;
    }
    .modal-content canvas {
      border: 1px solid #ccc;
      cursor: default;
    }
    .modal-buttons {
      margin-top: 15px;
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
    }
    .modal-close {
      background-color: #666;
    }
    .modal-close:hover {
      background-color: #555;
    }
    .status {
      font-size: 14px;
      color: #666;
      padding: 10px;
      background-color: #f0f0f0;
      border-radius: 4px;
      min-height: 40px;
    }
    .progress-container {
      width: 100%;
      height: 20px;
      background-color: #e0e0e0;
      border-radius: 10px;
      overflow: hidden;
      margin-top: 5px;
    }
    .progress-bar {
      height: 100%;
      background-color: #9C27B0;
      width: 0%;
      transition: width 0.1s;
    }
    .mode-info {
      font-size: 12px;
      color: #888;
      margin-top: 5px;
    }
    footer {
      text-align: center;
      margin-top: 20px;
      color: #888;
      font-size: 12px;
    }
    footer a {
      color: #2196F3;
      text-decoration: none;
    }
    footer a:hover {
      text-decoration: underline;
    }
    .lang-switch {
      text-align: right;
      margin-bottom: 10px;
    }
    .lang-switch a {
      color: #2196F3;
      text-decoration: none;
    }
  </style>
</head>
<body>
  <div class="lang-switch">
    <a href="en.html">ğŸ‡ºğŸ‡¸ English</a>
  </div>
  
  <h1>ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã«ã‚ˆã‚‹è½æ›¸ãæŠ½è±¡åŒ–</h1>
  
  <div class="container">
    <!-- å·¦ãƒ‘ãƒãƒ«: å…¥åŠ› -->
    <div class="left-panel">
      <div class="panel-title">å…¥åŠ›ãƒ‘ãƒ¬ãƒƒãƒˆ</div>
      <canvas id="drawCanvas" width="600" height="400"></canvas>
      
      <div class="controls">
        <div class="control-group">
          <label for="multiStrokeMode">
            <input type="checkbox" id="multiStrokeMode" checked> è¤‡æ•°ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰
          </label>
        </div>
        <div class="mode-info" id="modeInfo">è¤‡æ•°ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰: è¤‡æ•°ã®ç·šã‚’æã‘ã¾ã™ã€‚ç·šã®é–“ã¯è–„ãè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</div>
        
        <div class="control-group">
          <label for="kValue">ãƒ•ãƒ¼ãƒªã‚¨é …æ•° K:</label>
          <input type="number" id="kValue" value="10" min="1" max="1000">
        </div>
        
        <div class="button-group">
          <button id="processBtn">ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›</button>
          <button id="clearBtn" class="clear">ã‚¯ãƒªã‚¢</button>
          <button id="downloadInputBtn" class="secondary">å…¥åŠ›ç”»åƒã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
        </div>
        
        <div class="control-group">
          <label for="numFrames">ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ãƒ¬ãƒ¼ãƒ æ•°:</label>
          <input type="number" id="numFrames" value="30" min="5" max="100">
        </div>
        
        <div class="button-group">
          <button id="animationBtn" class="animation">ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”Ÿæˆ</button>
          <button id="downloadVideoBtn" class="animation" disabled>å‹•ç”»ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
        </div>
      </div>
    </div>
    
    <!-- å³ãƒ‘ãƒãƒ«: å‡ºåŠ› -->
    <div class="right-panel">
      <div class="panel-title">ç”Ÿæˆã•ã‚ŒãŸç”»åƒ</div>
      <canvas id="reconCanvas" width="600" height="400"></canvas>
      
      <div class="controls">
        <div class="status" id="statusText">æç”»ã—ã¦ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„</div>
        <div class="progress-container" id="progressContainer" style="display: none;">
          <div class="progress-bar" id="progressBar"></div>
        </div>
        <div class="button-group">
          <button id="downloadOutputBtn" class="secondary">ç”Ÿæˆç”»åƒã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
          <button id="shareBtn" class="share" disabled>QRã‚«ãƒ¼ãƒ‰ä½œæˆ</button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- QRã‚«ãƒ¼ãƒ‰ãƒ¢ãƒ¼ãƒ€ãƒ« -->
  <div id="shareModal" class="modal-overlay">
    <div class="modal-content">
      <h2>ğŸ“œ ã‚¢ãƒ¼ãƒ†ã‚£ãƒ•ã‚¡ã‚¯ãƒˆï¼ˆæ’ä¹…ä¿å­˜ã‚«ãƒ¼ãƒ‰ï¼‰</h2>
      <canvas id="cardCanvas" width="800" height="900"></canvas>
      <div class="modal-buttons">
        <button id="downloadCardBtn" class="secondary">ã‚«ãƒ¼ãƒ‰ç”»åƒã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
        <button id="copyUrlBtn" class="secondary">URLã‚’ã‚³ãƒ”ãƒ¼</button>
        <button id="closeModalBtn" class="modal-close">é–‰ã˜ã‚‹</button>
      </div>
    </div>
  </div>
  
  <footer>
    <p>Created by <a href="https://github.com/milky1210" target="_blank">milky1210</a> | <a href="https://github.com/milky1210/FourierPicture" target="_blank">GitHub</a></p>
    <p>First Published: 2025-11-27 (See <a href="https://github.com/milky1210/FourierPicture/commits/main" target="_blank">git history</a> for precise timestamp)</p>
  </footer>
  
  <script>
    // ============================================
    // FFTå®Ÿè£…ï¼ˆJavaScriptç‰ˆï¼‰
    // ============================================
    
    // è¤‡ç´ æ•°ã‚¯ãƒ©ã‚¹
    class Complex {
      constructor(re, im) {
        this.re = re;
        this.im = im;
      }
      
      add(other) {
        return new Complex(this.re + other.re, this.im + other.im);
      }
      
      sub(other) {
        return new Complex(this.re - other.re, this.im - other.im);
      }
      
      mul(other) {
        return new Complex(
          this.re * other.re - this.im * other.im,
          this.re * other.im + this.im * other.re
        );
      }
      
      scale(s) {
        return new Complex(this.re * s, this.im * s);
      }
      
      abs() {
        return Math.sqrt(this.re * this.re + this.im * this.im);
      }
    }
    
    // DFTï¼ˆé›¢æ•£ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ï¼‰- ä»»æ„ã®é•·ã•ã«å¯¾å¿œ
    function dft(input) {
      const N = input.length;
      const output = [];
      
      for (let k = 0; k < N; k++) {
        let sum = new Complex(0, 0);
        for (let n = 0; n < N; n++) {
          const angle = -2 * Math.PI * k * n / N;
          const exp = new Complex(Math.cos(angle), Math.sin(angle));
          sum = sum.add(input[n].mul(exp));
        }
        output.push(sum);
      }
      
      return output;
    }
    
    // FFTå‘¨æ³¢æ•°é…åˆ—ã‚’ç”Ÿæˆ
    function fftfreq(N) {
      const freqs = [];
      for (let i = 0; i < N; i++) {
        if (i < Math.floor((N + 1) / 2)) {
          freqs.push(i / N);
        } else {
          freqs.push((i - N) / N);
        }
      }
      return freqs;
    }
    
    // 2Dç‰ˆãƒ•ãƒ¼ãƒªã‚¨å†æ§‹æˆ
    function reconstructFourier2d(points, K) {
      const N = points.length;
      if (N === 0) return [];
      
      // è¤‡ç´ æ•°é…åˆ—ã«å¤‰æ›
      const z = points.map(p => new Complex(p[0], p[1]));
      
      // DFTè¨ˆç®—
      const F = dft(z);
      const freqs = fftfreq(N);
      
      // æŒ¯å¹…ã§ã‚½ãƒ¼ãƒˆ
      const amplitudes = F.map(c => c.abs());
      const indices = Array.from({ length: N }, (_, i) => i);
      indices.sort((a, b) => amplitudes[b] - amplitudes[a]);
      
      // ä¸Šä½Kå€‹ã‚’é¸æŠ
      const actualK = Math.min(K, N);
      const selectedIndices = indices.slice(0, actualK);
      
      // å†æ§‹æˆ
      const numOutputPoints = Math.max(N, 200);
      const result = [];
      
      for (let i = 0; i < numOutputPoints; i++) {
        const t = i / numOutputPoints;
        let sum = new Complex(0, 0);
        
        for (const k of selectedIndices) {
          const freq = freqs[k] * N;
          const angle = 2 * Math.PI * freq * t;
          const exp = new Complex(Math.cos(angle), Math.sin(angle));
          sum = sum.add(F[k].scale(1 / N).mul(exp));
        }
        
        result.push([sum.re, sum.im]);
      }
      
      return result;
    }
    
    // 3Dç‰ˆãƒ•ãƒ¼ãƒªã‚¨å†æ§‹æˆï¼ˆx, y, penï¼‰
    function reconstructFourier3d(points, K) {
      const N = points.length;
      if (N === 0) return [];
      
      // å„è»¸ã‚’è¤‡ç´ æ•°é…åˆ—ã«ï¼ˆå®Ÿéƒ¨ã®ã¿ä½¿ç”¨ï¼‰
      const x = points.map(p => new Complex(p[0], 0));
      const y = points.map(p => new Complex(p[1], 0));
      const pen = points.map(p => new Complex(p[2], 0));
      
      // DFTè¨ˆç®—
      const Fx = dft(x);
      const Fy = dft(y);
      const Fpen = dft(pen);
      const freqs = fftfreq(N);
      
      // æŒ¯å¹…ã®åˆè¨ˆã§ã‚½ãƒ¼ãƒˆ
      const amplitudes = [];
      for (let i = 0; i < N; i++) {
        amplitudes.push(Fx[i].abs() + Fy[i].abs() + Fpen[i].abs());
      }
      const indices = Array.from({ length: N }, (_, i) => i);
      indices.sort((a, b) => amplitudes[b] - amplitudes[a]);
      
      // ä¸Šä½Kå€‹ã‚’é¸æŠ
      const actualK = Math.min(K, N);
      const selectedIndices = indices.slice(0, actualK);
      
      // å†æ§‹æˆ
      const numOutputPoints = Math.max(N, 200);
      const result = [];
      
      for (let i = 0; i < numOutputPoints; i++) {
        const t = i / numOutputPoints;
        let sumX = new Complex(0, 0);
        let sumY = new Complex(0, 0);
        let sumPen = new Complex(0, 0);
        
        for (const k of selectedIndices) {
          const freq = freqs[k] * N;
          const angle = 2 * Math.PI * freq * t;
          const exp = new Complex(Math.cos(angle), Math.sin(angle));
          sumX = sumX.add(Fx[k].scale(1 / N).mul(exp));
          sumY = sumY.add(Fy[k].scale(1 / N).mul(exp));
          sumPen = sumPen.add(Fpen[k].scale(1 / N).mul(exp));
        }
        
        // penå€¤ã‚’0-1ã«ã‚¯ãƒªãƒƒãƒ—
        const penVal = Math.max(0, Math.min(1, sumPen.re));
        result.push([sumX.re, sumY.re, penVal]);
      }
      
      return result;
    }
    
    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ãƒ¬ãƒ¼ãƒ ç”Ÿæˆ
    function generateAnimationFrames(points, numFrames, is3d) {
      const N = points.length;
      if (N === 0) return [];
      if (N < 2) return [{ K: N, points: points, isFinal: true }];
      
      const reconstructFn = is3d ? reconstructFourier3d : reconstructFourier2d;
      
      const kMin = 2;
      const kMax = N;
      
      // Kå€¤ã‚’ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
      const kValuesSet = new Set();
      for (let i = 0; i < numFrames; i++) {
        let k;
        if (numFrames === 1) {
          k = kMax;
        } else {
          const t = i / (numFrames - 1);
          const tAdjusted = Math.pow(t, 0.6);
          const logK = Math.log(kMin) + (Math.log(kMax) - Math.log(kMin)) * tAdjusted;
          k = Math.round(Math.exp(logK));
        }
        k = Math.max(kMin, Math.min(k, kMax));
        kValuesSet.add(k);
      }
      
      const kValues = Array.from(kValuesSet).sort((a, b) => a - b);
      
      // ãƒ•ãƒ¬ãƒ¼ãƒ ç”Ÿæˆ
      const frames = [];
      for (const k of kValues) {
        const reconstructed = reconstructFn(points, k);
        frames.push({
          K: k,
          points: reconstructed,
          isFinal: false
        });
      }
      
      // æœ€çµ‚ãƒ•ãƒ¬ãƒ¼ãƒ 
      const finalPoints = reconstructFn(points, N);
      frames.push({
        K: N,
        points: finalPoints,
        isFinal: true
      });
      
      return frames;
    }

    // ============================================
    // ãƒ‡ãƒ¼ã‚¿ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ/ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿèƒ½
    // QRã‚³ãƒ¼ãƒ‰ç”Ÿæˆã«ã¯ qrcode-generator CDN ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨
    // ============================================
    
    // æ•°å€¤ã‚’æŒ‡å®šæ¡ã«ä¸¸ã‚ã‚‹
    function roundNumber(num, decimals) {
      const factor = Math.pow(10, decimals);
      return Math.round(num * factor) / factor;
    }
    
    // ãƒ•ãƒ¼ãƒªã‚¨ä¿‚æ•°ã‚’å–å¾—ï¼ˆå…±æœ‰ç”¨ã«Kå€‹ã«åˆ¶é™ï¼‰
    function getFourierCoefficients(points, K, is3d) {
      const N = points.length;
      if (N === 0) return null;
      
      const actualK = Math.min(K, N);
      
      if (is3d) {
        const x = points.map(p => new Complex(p[0], 0));
        const y = points.map(p => new Complex(p[1], 0));
        const pen = points.map(p => new Complex(p[2], 0));
        
        const Fx = dft(x);
        const Fy = dft(y);
        const Fpen = dft(pen);
        
        // æŒ¯å¹…ã§ã‚½ãƒ¼ãƒˆ
        const amplitudes = [];
        for (let i = 0; i < N; i++) {
          amplitudes.push(Fx[i].abs() + Fy[i].abs() + Fpen[i].abs());
        }
        const indices = Array.from({ length: N }, (_, i) => i);
        indices.sort((a, b) => amplitudes[b] - amplitudes[a]);
        const selectedIndices = indices.slice(0, actualK);
        
        // ä¿‚æ•°ãƒ‡ãƒ¼ã‚¿ï¼ˆRe, Im ã®äº¤äº’é…åˆ—ï¼‰
        const coeffX = [];
        const coeffY = [];
        const coeffPen = [];
        
        for (const k of selectedIndices) {
          coeffX.push(roundNumber(Fx[k].re, 3), roundNumber(Fx[k].im, 3));
          coeffY.push(roundNumber(Fy[k].re, 3), roundNumber(Fy[k].im, 3));
          coeffPen.push(roundNumber(Fpen[k].re, 3), roundNumber(Fpen[k].im, 3));
        }
        
        return {
          f: "v(t)=Sum(Re(Fk*exp(i*2*pi*k*t)))",
          n: N,
          k: selectedIndices.map(i => i),
          d: [coeffX, coeffY, coeffPen]
        };
      } else {
        const z = points.map(p => new Complex(p[0], p[1]));
        const F = dft(z);
        
        const amplitudes = F.map(c => c.abs());
        const indices = Array.from({ length: N }, (_, i) => i);
        indices.sort((a, b) => amplitudes[b] - amplitudes[a]);
        const selectedIndices = indices.slice(0, actualK);
        
        const coeffZ = [];
        for (const k of selectedIndices) {
          coeffZ.push(roundNumber(F[k].re, 3), roundNumber(F[k].im, 3));
        }
        
        return {
          f: "z(t)=Sum(Fk*exp(i*2*pi*k*t))",
          n: N,
          k: selectedIndices.map(i => i),
          d: [coeffZ]
        };
      }
    }
    
    // ä¿‚æ•°ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å†æ§‹æˆ
    function reconstructFromCoefficients(data) {
      const N = data.n;
      const K = data.k;
      const is3d = data.d.length === 3;
      const freqs = fftfreq(N);
      
      const numOutputPoints = Math.max(N, 200);
      const result = [];
      
      if (is3d) {
        const coeffX = data.d[0];
        const coeffY = data.d[1];
        const coeffPen = data.d[2];
        
        for (let i = 0; i < numOutputPoints; i++) {
          const t = i / numOutputPoints;
          let sumX = new Complex(0, 0);
          let sumY = new Complex(0, 0);
          let sumPen = new Complex(0, 0);
          
          for (let j = 0; j < K.length; j++) {
            const k = K[j];
            const freq = freqs[k] * N;
            const angle = 2 * Math.PI * freq * t;
            const exp = new Complex(Math.cos(angle), Math.sin(angle));
            
            const Fxk = new Complex(coeffX[j * 2], coeffX[j * 2 + 1]);
            const Fyk = new Complex(coeffY[j * 2], coeffY[j * 2 + 1]);
            const Fpenk = new Complex(coeffPen[j * 2], coeffPen[j * 2 + 1]);
            
            sumX = sumX.add(Fxk.scale(1 / N).mul(exp));
            sumY = sumY.add(Fyk.scale(1 / N).mul(exp));
            sumPen = sumPen.add(Fpenk.scale(1 / N).mul(exp));
          }
          
          const penVal = Math.max(0, Math.min(1, sumPen.re));
          result.push([sumX.re, sumY.re, penVal]);
        }
      } else {
        const coeffZ = data.d[0];
        
        for (let i = 0; i < numOutputPoints; i++) {
          const t = i / numOutputPoints;
          let sum = new Complex(0, 0);
          
          for (let j = 0; j < K.length; j++) {
            const k = K[j];
            const freq = freqs[k] * N;
            const angle = 2 * Math.PI * freq * t;
            const exp = new Complex(Math.cos(angle), Math.sin(angle));
            
            const Fk = new Complex(coeffZ[j * 2], coeffZ[j * 2 + 1]);
            sum = sum.add(Fk.scale(1 / N).mul(exp));
          }
          
          result.push([sum.re, sum.im]);
        }
      }
      
      return result;
    }
    
    // ãƒ‡ãƒ¼ã‚¿ã‚’Base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰
    function encodeDataToBase64(data) {
      const jsonStr = JSON.stringify(data);
      // UTF-8å¯¾å¿œã®Base64ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‰
      const utf8Bytes = new TextEncoder().encode(jsonStr);
      let binaryStr = '';
      for (const byte of utf8Bytes) {
        binaryStr += String.fromCharCode(byte);
      }
      return btoa(binaryStr);
    }
    
    // Base64ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ‡ã‚³ãƒ¼ãƒ‰
    function decodeDataFromBase64(base64Str) {
      try {
        const binaryStr = atob(base64Str);
        const bytes = new Uint8Array(binaryStr.length);
        for (let i = 0; i < binaryStr.length; i++) {
          bytes[i] = binaryStr.charCodeAt(i);
        }
        const jsonStr = new TextDecoder().decode(bytes);
        return JSON.parse(jsonStr);
      } catch (e) {
        console.error('Failed to decode data:', e);
        return null;
      }
    }
    
    // å…±æœ‰URLã‚’ç”Ÿæˆ
    function generateShareUrl(coefficients) {
      const encoded = encodeDataToBase64(coefficients);
      const baseUrl = window.location.origin + window.location.pathname;
      return baseUrl + '?d=' + encodeURIComponent(encoded);
    }
    
    // URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿
    function loadFromUrlParams() {
      const urlParams = new URLSearchParams(window.location.search);
      const dataParam = urlParams.get('d');
      
      if (dataParam) {
        try {
          const decoded = decodeDataFromBase64(decodeURIComponent(dataParam));
          if (decoded && decoded.d && decoded.n && decoded.k) {
            return decoded;
          }
        } catch (e) {
          console.error('Failed to load data from URL:', e);
        }
      }
      return null;
    }
    
    // QRã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆã—ã¦Canvasã«æç”»
    function generateQRCode(url, targetCanvas, cellSize) {
      try {
        const qr = qrcode(0, 'L'); // è‡ªå‹•ãƒãƒ¼ã‚¸ãƒ§ãƒ³, ä½èª¤ã‚Šè¨‚æ­£
        qr.addData(url);
        qr.make();
        
        const ctx = targetCanvas.getContext('2d');
        const moduleCount = qr.getModuleCount();
        const margin = cellSize * 2;
        const size = moduleCount * cellSize + margin * 2;
        
        targetCanvas.width = size;
        targetCanvas.height = size;
        
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, size, size);
        
        for (let row = 0; row < moduleCount; row++) {
          for (let col = 0; col < moduleCount; col++) {
            ctx.fillStyle = qr.isDark(row, col) ? '#000000' : '#ffffff';
            ctx.fillRect(
              col * cellSize + margin,
              row * cellSize + margin,
              cellSize,
              cellSize
            );
          }
        }
        
        return { width: size, height: size };
      } catch (e) {
        console.error('QR code generation failed:', e);
        return null;
      }
    }
    
    // ç¾åœ¨ã®ä¿‚æ•°ãƒ‡ãƒ¼ã‚¿ï¼ˆå…±æœ‰ç”¨ï¼‰
    let currentCoefficients = null;

    // ============================================
    // UIéƒ¨åˆ†
    // ============================================
    
    // æç”»ã‚­ãƒ£ãƒ³ãƒã‚¹ã®è¨­å®š
    const canvas = document.getElementById('drawCanvas');
    const ctx = canvas.getContext('2d');
    let drawing = false;
    
    // ç‚¹ç¾¤ãƒ‡ãƒ¼ã‚¿
    let currentStroke = [];
    let strokes = [];
    
    // ãƒ¢ãƒ¼ãƒ‰
    let multiStrokeMode = true;

    // å†æ§‹æˆã‚­ãƒ£ãƒ³ãƒã‚¹ã®è¨­å®š
    const reconCanvas = document.getElementById('reconCanvas');
    const rctx = reconCanvas.getContext('2d');
    
    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨
    let animationFrames = [];
    let currentFrameIndex = 0;
    let isPlaying = false;
    let animationId = null;

    // èƒŒæ™¯ã‚’ç™½ã§å¡—ã‚Šã¤ã¶ã™
    function initCanvas(context, canvasElement) {
      context.fillStyle = 'white';
      context.fillRect(0, 0, canvasElement.width, canvasElement.height);
    }

    function updateStatus(text) {
      document.getElementById('statusText').textContent = text;
    }

    function showProgress(show) {
      document.getElementById('progressContainer').style.display = show ? 'block' : 'none';
    }

    function setProgress(percent) {
      document.getElementById('progressBar').style.width = percent + '%';
    }

    // å…¥åŠ›ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’å†æç”»
    function redrawInputCanvas() {
      initCanvas(ctx, canvas);
      
      for (const stroke of strokes) {
        if (stroke.length > 0) {
          ctx.beginPath();
          ctx.moveTo(stroke[0][0], stroke[0][1]);
          for (let i = 1; i < stroke.length; i++) {
            ctx.lineTo(stroke[i][0], stroke[i][1]);
          }
          ctx.strokeStyle = 'black';
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      }
      
      if (currentStroke.length > 0) {
        ctx.beginPath();
        ctx.moveTo(currentStroke[0][0], currentStroke[0][1]);
        for (let i = 1; i < currentStroke.length; i++) {
          ctx.lineTo(currentStroke[i][0], currentStroke[i][1]);
        }
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }

    // 3Dç‚¹ç¾¤ã‚’ç”Ÿæˆ
    function generatePoints3d() {
      const allStrokes = [...strokes];
      if (currentStroke.length > 0) {
        allStrokes.push(currentStroke);
      }
      
      if (allStrokes.length === 0) return [];
      
      const result = [];
      
      for (let s = 0; s < allStrokes.length; s++) {
        const stroke = allStrokes[s];
        
        if (s > 0 && result.length > 0 && stroke.length > 0) {
          const lastPoint = result[result.length - 1];
          const firstPoint = stroke[0];
          
          const numInterp = 10;
          for (let i = 1; i <= numInterp; i++) {
            const t = i / numInterp;
            const x = lastPoint[0] + (firstPoint[0] - lastPoint[0]) * t;
            const y = lastPoint[1] + (firstPoint[1] - lastPoint[1]) * t;
            result.push([x, y, 0]);
          }
        }
        
        for (const pt of stroke) {
          result.push([pt[0], pt[1], 1]);
        }
      }
      
      if (result.length > 0) {
        const lastPoint = result[result.length - 1];
        const firstPoint = result[0];
        
        const numInterp = 10;
        for (let i = 1; i <= numInterp; i++) {
          const t = i / numInterp;
          const x = lastPoint[0] + (firstPoint[0] - lastPoint[0]) * t;
          const y = lastPoint[1] + (firstPoint[1] - lastPoint[1]) * t;
          result.push([x, y, 0]);
        }
      }
      
      return result;
    }

    // 2Dç‚¹ç¾¤ã‚’ç”Ÿæˆ
    function generatePoints2d() {
      const allStrokes = [...strokes];
      if (currentStroke.length > 0) {
        allStrokes.push(currentStroke);
      }
      
      const result = [];
      for (const stroke of allStrokes) {
        for (const pt of stroke) {
          result.push([pt[0], pt[1]]);
        }
      }
      return result;
    }

    initCanvas(ctx, canvas);
    initCanvas(rctx, reconCanvas);

    // ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
    document.getElementById('multiStrokeMode').addEventListener('change', (e) => {
      multiStrokeMode = e.target.checked;
      const modeInfo = document.getElementById('modeInfo');
      if (multiStrokeMode) {
        modeInfo.textContent = 'è¤‡æ•°ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰: è¤‡æ•°ã®ç·šã‚’æã‘ã¾ã™ã€‚ç·šã®é–“ã¯è–„ãè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚';
      } else {
        modeInfo.textContent = 'ä¸€ç­†æ›¸ããƒ¢ãƒ¼ãƒ‰: æããŸã³ã«ãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã™';
      }
    });

    // æç”»ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆãƒã‚¦ã‚¹ï¼‰
    canvas.addEventListener('mousedown', (e) => {
      drawing = true;
      
      if (!multiStrokeMode) {
        strokes = [];
        currentStroke = [];
        initCanvas(ctx, canvas);
      }
      
      currentStroke = [];
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top) * scaleY;
      currentStroke.push([x, y]);
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 2;
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!drawing) return;
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top) * scaleY;
      currentStroke.push([x, y]);
      ctx.lineTo(x, y);
      ctx.stroke();
    });

    canvas.addEventListener('mouseup', () => {
      if (drawing && currentStroke.length > 0) {
        strokes.push([...currentStroke]);
        currentStroke = [];
      }
      drawing = false;
    });

    canvas.addEventListener('mouseleave', () => {
      if (drawing && currentStroke.length > 0) {
        strokes.push([...currentStroke]);
        currentStroke = [];
      }
      drawing = false;
    });

    // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆ
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      drawing = true;
      
      if (!multiStrokeMode) {
        strokes = [];
        currentStroke = [];
        initCanvas(ctx, canvas);
      }
      
      currentStroke = [];
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const touch = e.touches[0];
      const x = (touch.clientX - rect.left) * scaleX;
      const y = (touch.clientY - rect.top) * scaleY;
      currentStroke.push([x, y]);
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 2;
    });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (!drawing) return;
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const touch = e.touches[0];
      const x = (touch.clientX - rect.left) * scaleX;
      const y = (touch.clientY - rect.top) * scaleY;
      currentStroke.push([x, y]);
      ctx.lineTo(x, y);
      ctx.stroke();
    });

    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      if (drawing && currentStroke.length > 0) {
        strokes.push([...currentStroke]);
        currentStroke = [];
      }
      drawing = false;
    });

    // 3Dç‚¹ç¾¤ã‚’æç”»
    const PEN_THRESHOLD = 0.5;
    
    function drawPoints3d(context, canvasEl, pts) {
      initCanvas(context, canvasEl);
      if (pts.length < 2) return;
      
      for (let i = 1; i < pts.length; i++) {
        const x0 = pts[i-1][0];
        const y0 = pts[i-1][1];
        const pen0 = pts[i-1][2];
        const x1 = pts[i][0];
        const y1 = pts[i][1];
        const pen1 = pts[i][2];
        
        const penAvg = (pen0 + pen1) / 2;
        
        if (penAvg < PEN_THRESHOLD) continue;
        
        const alpha = (penAvg - PEN_THRESHOLD) / (1 - PEN_THRESHOLD);
        
        context.beginPath();
        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.strokeStyle = `rgba(255, 0, 0, ${alpha})`;
        context.lineWidth = 2;
        context.stroke();
      }
    }

    // 2Dç‚¹ç¾¤ã‚’æç”»
    function drawPoints2d(context, canvasEl, pts, color = 'red') {
      initCanvas(context, canvasEl);
      if (pts.length > 0) {
        context.beginPath();
        context.moveTo(pts[0][0], pts[0][1]);
        for (let i = 1; i < pts.length; i++) {
          context.lineTo(pts[i][0], pts[i][1]);
        }
        context.strokeStyle = color;
        context.lineWidth = 2;
        context.stroke();
      }
    }

    // ç‚¹ç¾¤ã‚’æç”»
    function drawPoints(context, canvasEl, pts) {
      if (pts.length === 0) return;
      
      if (pts[0].length === 3) {
        drawPoints3d(context, canvasEl, pts);
      } else {
        drawPoints2d(context, canvasEl, pts);
      }
    }

    // ã‚¯ãƒªã‚¢ãƒœã‚¿ãƒ³
    document.getElementById('clearBtn').addEventListener('click', () => {
      strokes = [];
      currentStroke = [];
      animationFrames = [];
      if (animationId) {
        cancelAnimationFrame(animationId);
        clearTimeout(animationId);
        animationId = null;
      }
      isPlaying = false;
      initCanvas(ctx, canvas);
      initCanvas(rctx, reconCanvas);
      document.getElementById('downloadVideoBtn').disabled = true;
      updateStatus('æç”»ã—ã¦ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„');
    });

    // ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ãƒœã‚¿ãƒ³
    document.getElementById('processBtn').addEventListener('click', () => {
      // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’åœæ­¢
      if (animationId) {
        cancelAnimationFrame(animationId);
        clearTimeout(animationId);
        animationId = null;
      }
      isPlaying = false;
      showProgress(false);
      
      const points2d = generatePoints2d();
      const points3d = generatePoints3d();
      
      if (points2d.length === 0) {
        alert("ã¾ãšã¯ã‚­ãƒ£ãƒ³ãƒã‚¹ä¸Šã«æã„ã¦ãã ã•ã„");
        return;
      }
      
      const K = parseInt(document.getElementById('kValue').value);
      if (isNaN(K) || K < 1) {
        alert("K ã®å€¤ã¯1ä»¥ä¸Šã®æ•´æ•°ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
        return;
      }

      updateStatus('å‡¦ç†ä¸­...');
      
      const useMultiStroke = multiStrokeMode;
      const inputPoints = useMultiStroke ? points3d : points2d;
      
      // JavaScriptã§ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã‚’å®Ÿè¡Œ
      setTimeout(() => {
        try {
          let result;
          if (useMultiStroke) {
            result = reconstructFourier3d(inputPoints, K);
          } else {
            result = reconstructFourier2d(inputPoints, K);
          }
          
          drawPoints(rctx, reconCanvas, result);
          const strokeInfo = useMultiStroke ? `, ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯æ•°: ${strokes.length}` : '';
          updateStatus(`ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›å®Œäº† (K=${K}, å…¥åŠ›ç‚¹æ•°: ${inputPoints.length}${strokeInfo})`);
        } catch (error) {
          console.error("Error:", error);
          alert("ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: " + error.message);
          updateStatus('ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
        }
      }, 10);
    });

    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”Ÿæˆãƒœã‚¿ãƒ³
    document.getElementById('animationBtn').addEventListener('click', () => {
      const points2d = generatePoints2d();
      const points3d = generatePoints3d();
      
      if (points2d.length === 0) {
        alert("ã¾ãšã¯ã‚­ãƒ£ãƒ³ãƒã‚¹ä¸Šã«æã„ã¦ãã ã•ã„");
        return;
      }
      
      const numFrames = parseInt(document.getElementById('numFrames').value);
      if (isNaN(numFrames) || numFrames < 5) {
        alert("ãƒ•ãƒ¬ãƒ¼ãƒ æ•°ã¯5ä»¥ä¸Šã®æ•´æ•°ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
        return;
      }

      if (animationId) {
        cancelAnimationFrame(animationId);
        clearTimeout(animationId);
        animationId = null;
      }

      updateStatus('ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆä¸­...');
      showProgress(true);
      setProgress(0);

      const useMultiStroke = multiStrokeMode;
      const inputPoints = useMultiStroke ? points3d : points2d;

      // JavaScriptã§ãƒ•ãƒ¬ãƒ¼ãƒ ç”Ÿæˆ
      setTimeout(() => {
        try {
          animationFrames = generateAnimationFrames(inputPoints, numFrames, useMultiStroke);
          
          if (animationFrames.length === 0) {
            updateStatus('ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“');
            showProgress(false);
            return;
          }
          
          currentFrameIndex = 0;
          isPlaying = true;
          document.getElementById('downloadVideoBtn').disabled = false;
          
          updateStatus(`ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å†ç”Ÿä¸­ (${animationFrames.length}ãƒ•ãƒ¬ãƒ¼ãƒ )`);
          
          playAnimation();
          
        } catch (error) {
          console.error("Error:", error);
          alert("ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: " + error.message);
          updateStatus('ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ');
          showProgress(false);
        }
      }, 10);
    });

    function playAnimation() {
      if (!isPlaying || animationFrames.length === 0) return;
      
      const frame = animationFrames[currentFrameIndex];
      drawPoints(rctx, reconCanvas, frame.points);
      
      const progress = ((currentFrameIndex + 1) / animationFrames.length) * 100;
      setProgress(progress);
      
      if (frame.isFinal) {
        updateStatus(`å®Œæˆï¼ K = ${frame.K} (å…¨æˆåˆ†)`);
      } else {
        updateStatus(`K = ${frame.K} (ãƒ•ãƒ¬ãƒ¼ãƒ  ${currentFrameIndex + 1}/${animationFrames.length})`);
      }
      
      currentFrameIndex++;
      if (currentFrameIndex >= animationFrames.length) {
        currentFrameIndex = 0;
      }
      
      const delay = frame.isFinal ? 3000 : 100;
      
      animationId = setTimeout(() => {
        requestAnimationFrame(playAnimation);
      }, delay);
    }

    // å‹•ç”»ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³
    document.getElementById('downloadVideoBtn').addEventListener('click', async () => {
      if (animationFrames.length === 0) {
        alert("ã¾ãšã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„");
        return;
      }

      isPlaying = false;
      if (animationId) {
        cancelAnimationFrame(animationId);
        clearTimeout(animationId);
        animationId = null;
      }

      updateStatus('å‹•ç”»ã‚’ç”Ÿæˆä¸­...');
      showProgress(true);
      setProgress(0);

      try {
        const stream = reconCanvas.captureStream(30);
        const mediaRecorder = new MediaRecorder(stream, {
          mimeType: 'video/webm;codecs=vp9',
          videoBitsPerSecond: 5000000
        });
        
        const chunks = [];
        mediaRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) {
            chunks.push(e.data);
          }
        };
        
        mediaRecorder.onstop = () => {
          const blob = new Blob(chunks, { type: 'video/webm' });
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = 'fourier_animation.webm';
          link.click();
          URL.revokeObjectURL(url);
          
          updateStatus('å‹•ç”»ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãŒå®Œäº†ã—ã¾ã—ãŸ');
          showProgress(false);
          
          isPlaying = true;
          playAnimation();
        };

        mediaRecorder.start();
        
        for (let i = 0; i < animationFrames.length; i++) {
          const frame = animationFrames[i];
          drawPoints(rctx, reconCanvas, frame.points);
          setProgress(((i + 1) / animationFrames.length) * 100);
          
          const delay = frame.isFinal ? 3000 : 100;
          await new Promise(resolve => setTimeout(resolve, delay));
        }
        
        mediaRecorder.stop();
        
      } catch (error) {
        console.error("Error:", error);
        
        alert("å‹•ç”»ç”Ÿæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ãƒ–ãƒ©ã‚¦ã‚¶ãŒWebMå½¢å¼ã«å¯¾å¿œã—ã¦ã„ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚");
        updateStatus('å‹•ç”»ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ');
        showProgress(false);
        
        isPlaying = true;
        playAnimation();
      }
    });

    // å…¥åŠ›ç”»åƒãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
    document.getElementById('downloadInputBtn').addEventListener('click', () => {
      const link = document.createElement('a');
      link.download = 'input_image.png';
      link.href = canvas.toDataURL('image/png');
      link.click();
    });

    // ç”Ÿæˆç”»åƒãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
    document.getElementById('downloadOutputBtn').addEventListener('click', () => {
      const link = document.createElement('a');
      link.download = 'fourier_image.png';
      link.href = reconCanvas.toDataURL('image/png');
      link.click();
    });

    // ============================================
    // QRã‚«ãƒ¼ãƒ‰ç”Ÿæˆãƒ»å…±æœ‰æ©Ÿèƒ½
    // ============================================
    
    const shareModal = document.getElementById('shareModal');
    const cardCanvas = document.getElementById('cardCanvas');
    const cardCtx = cardCanvas.getContext('2d');
    let currentShareUrl = '';
    
    // QRã‚«ãƒ¼ãƒ‰ç”»åƒã‚’ç”Ÿæˆ
    function generateArtifactCard(artCanvas, coefficients) {
      const shareUrl = generateShareUrl(coefficients);
      currentShareUrl = shareUrl;
      
      // ã‚«ãƒ¼ãƒ‰ã‚µã‚¤ã‚ºè¨­å®š
      const cardWidth = 800;
      const cardHeight = 1000;
      const margin = 30;
      const artSize = 500;
      const qrSize = 180;
      
      cardCanvas.width = cardWidth;
      cardCanvas.height = cardHeight;
      
      // èƒŒæ™¯
      cardCtx.fillStyle = '#ffffff';
      cardCtx.fillRect(0, 0, cardWidth, cardHeight);
      
      // ã‚¿ã‚¤ãƒˆãƒ«
      cardCtx.fillStyle = '#333333';
      cardCtx.font = 'bold 24px Arial, sans-serif';
      cardCtx.textAlign = 'center';
      cardCtx.fillText('Fourier Art Artifact', cardWidth / 2, margin + 25);
      
      // ã‚¢ãƒ¼ãƒˆç”»åƒã‚’ä¸­å¤®ã«é…ç½®
      const artX = (cardWidth - artSize) / 2;
      const artY = margin + 50;
      
      // æ ç·š
      cardCtx.strokeStyle = '#333333';
      cardCtx.lineWidth = 2;
      cardCtx.strokeRect(artX - 2, artY - 2, artSize + 4, artSize * (artCanvas.height / artCanvas.width) + 4);
      
      // ã‚¢ãƒ¼ãƒˆç”»åƒæç”»
      const artHeight = artSize * (artCanvas.height / artCanvas.width);
      cardCtx.drawImage(artCanvas, artX, artY, artSize, artHeight);
      
      // QRã‚³ãƒ¼ãƒ‰ç”Ÿæˆ
      const tempQrCanvas = document.createElement('canvas');
      const qrResult = generateQRCode(shareUrl, tempQrCanvas, 4);
      
      if (qrResult) {
        // QRã‚³ãƒ¼ãƒ‰ã‚’å³ä¸‹ã«é…ç½®
        const qrX = cardWidth - margin - qrSize;
        const qrY = artY + artHeight + 30;
        cardCtx.drawImage(tempQrCanvas, qrX, qrY, qrSize, qrSize);
        
        // QRãƒ©ãƒ™ãƒ«
        cardCtx.fillStyle = '#666666';
        cardCtx.font = '12px Arial, sans-serif';
        cardCtx.textAlign = 'center';
        cardCtx.fillText('Scan to restore', qrX + qrSize / 2, qrY + qrSize + 15);
      }
      
      // Rosetta Textï¼ˆå¾©å…ƒã®ãŸã‚ã®æ•°å¼æƒ…å ±ï¼‰
      const rosettaY = artY + artHeight + 50;
      const rosettaX = margin;
      
      cardCtx.fillStyle = '#333333';
      cardCtx.font = 'bold 14px monospace';
      cardCtx.textAlign = 'left';
      cardCtx.fillText('=== ROSETTA STONE FOR FUTURE ===', rosettaX, rosettaY);
      
      cardCtx.font = '12px monospace';
      cardCtx.fillStyle = '#555555';
      
      const rosettaLines = [
        'Format: IDFT (Real part only) of X, Y, Pen',
        'Formula: v(t) = (1/N) * Î£ Re(Fk * exp(i*2*Ï€*k*t))',
        '',
        'Data structure: { n: N, k: [indices], d: [coeffs] }',
        '  - N: Original point count',
        '  - k: Selected frequency indices (sorted by amplitude)',
        '  - d: [X coeffs, Y coeffs, Pen coeffs]',
        '       Each: [Re0, Im0, Re1, Im1, ...]',
        '',
        'To reconstruct:',
        '  1. Decode Base64 from URL parameter "d"',
        '  2. Parse JSON to get {n, k, d}',
        '  3. For t âˆˆ [0,1), compute:',
        '     x(t) = Î£ Re(Fxk * exp(i*2*Ï€*fk*N*t)) / N',
        '     y(t) = Î£ Re(Fyk * exp(i*2*Ï€*fk*N*t)) / N',
        '     pen(t) = clamp(Î£ Re(Fpenk * ...) / N, 0, 1)',
        '  4. Draw line when pen(t) > 0.5',
        '',
        `K = ${coefficients.k.length}, N = ${coefficients.n}`
      ];
      
      let lineY = rosettaY + 20;
      for (const line of rosettaLines) {
        cardCtx.fillText(line, rosettaX, lineY);
        lineY += 16;
      }
      
      // ãƒ•ãƒƒã‚¿ãƒ¼
      cardCtx.fillStyle = '#888888';
      cardCtx.font = '10px Arial, sans-serif';
      cardCtx.textAlign = 'center';
      cardCtx.fillText('Generated by FourierPicture | github.com/milky1210/FourierPicture', cardWidth / 2, cardHeight - 15);
      cardCtx.fillText(`Created: ${new Date().toISOString().split('T')[0]}`, cardWidth / 2, cardHeight - 30);
      
      return shareUrl;
    }
    
    // QRã‚«ãƒ¼ãƒ‰ä½œæˆãƒœã‚¿ãƒ³
    document.getElementById('shareBtn').addEventListener('click', () => {
      if (!currentCoefficients) {
        alert('ã¾ãšãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„');
        return;
      }
      
      generateArtifactCard(reconCanvas, currentCoefficients);
      shareModal.style.display = 'flex';
    });
    
    // ã‚«ãƒ¼ãƒ‰ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
    document.getElementById('downloadCardBtn').addEventListener('click', () => {
      const link = document.createElement('a');
      link.download = 'fourier_artifact_card.png';
      link.href = cardCanvas.toDataURL('image/png');
      link.click();
    });
    
    // URLã‚³ãƒ”ãƒ¼
    document.getElementById('copyUrlBtn').addEventListener('click', async () => {
      if (currentShareUrl) {
        try {
          await navigator.clipboard.writeText(currentShareUrl);
          alert('URLã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ');
        } catch (e) {
          // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
          const textArea = document.createElement('textarea');
          textArea.value = currentShareUrl;
          document.body.appendChild(textArea);
          textArea.select();
          document.execCommand('copy');
          document.body.removeChild(textArea);
          alert('URLã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ');
        }
      }
    });
    
    // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹
    document.getElementById('closeModalBtn').addEventListener('click', () => {
      shareModal.style.display = 'none';
    });
    
    // ãƒ¢ãƒ¼ãƒ€ãƒ«å¤–ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
    shareModal.addEventListener('click', (e) => {
      if (e.target === shareModal) {
        shareModal.style.display = 'none';
      }
    });
    
    // ============================================
    // URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰ã®å¾©å…ƒï¼ˆãƒ“ãƒ¥ãƒ¼ã‚¢ãƒ¼ãƒ¢ãƒ¼ãƒ‰ï¼‰
    // ============================================
    
    // å…±æœ‰ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’ç”Ÿæˆ
    function generateAnimationFramesFromCoefficients(data, numFrames) {
      const K = data.k.length;
      const is3d = data.d.length === 3;
      
      if (K === 0) return [];
      if (K < 2) {
        const points = reconstructFromCoefficients(data);
        return [{ K: K, points: points, isFinal: true }];
      }
      
      const kMin = 2;
      const kMax = K;
      
      const kValuesSet = new Set();
      for (let i = 0; i < numFrames; i++) {
        let k;
        if (numFrames === 1) {
          k = kMax;
        } else {
          const t = i / (numFrames - 1);
          const tAdjusted = Math.pow(t, 0.6);
          const logK = Math.log(kMin) + (Math.log(kMax) - Math.log(kMin)) * tAdjusted;
          k = Math.round(Math.exp(logK));
        }
        k = Math.max(kMin, Math.min(k, kMax));
        kValuesSet.add(k);
      }
      
      const kValues = Array.from(kValuesSet).sort((a, b) => a - b);
      
      const frames = [];
      for (const k of kValues) {
        // kå€‹ã®ä¿‚æ•°ã ã‘ã‚’ä½¿ç”¨
        const partialData = {
          f: data.f,
          n: data.n,
          k: data.k.slice(0, k),
          d: data.d.map(arr => arr.slice(0, k * 2))
        };
        const reconstructed = reconstructFromCoefficients(partialData);
        frames.push({
          K: k,
          points: reconstructed,
          isFinal: false
        });
      }
      
      // æœ€çµ‚ãƒ•ãƒ¬ãƒ¼ãƒ ï¼ˆå…¨ä¿‚æ•°ä½¿ç”¨ï¼‰
      const finalPoints = reconstructFromCoefficients(data);
      frames.push({
        K: K,
        points: finalPoints,
        isFinal: true
      });
      
      return frames;
    }
    
    // ãƒ“ãƒ¥ãƒ¼ã‚¢ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã®åˆæœŸåŒ–
    function initViewerMode(data) {
      const is3d = data.d.length === 3;
      
      // å·¦ãƒ‘ãƒãƒ«ã‚’éè¡¨ç¤ºã«ã—ã€å³ãƒ‘ãƒãƒ«ã‚’æ‹¡å¤§
      document.querySelector('.left-panel').style.display = 'none';
      document.querySelector('.right-panel').style.flex = '1';
      document.querySelector('.right-panel .panel-title').textContent = 'å…±æœ‰ã•ã‚ŒãŸãƒ•ãƒ¼ãƒªã‚¨ã‚¢ãƒ¼ãƒˆ';
      
      // ãƒœã‚¿ãƒ³ã®è¡¨ç¤ºã‚’å¤‰æ›´
      document.getElementById('shareBtn').style.display = 'none';
      
      // æ–°ã—ã„ãƒœã‚¿ãƒ³ã‚’è¿½åŠ 
      const buttonGroup = document.querySelector('.right-panel .button-group');
      
      // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å†ç”Ÿãƒœã‚¿ãƒ³
      const playBtn = document.createElement('button');
      playBtn.id = 'viewerPlayBtn';
      playBtn.className = 'animation';
      playBtn.textContent = 'ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å†ç”Ÿ';
      buttonGroup.appendChild(playBtn);
      
      // å‹•ç”»ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³
      const videoBtn = document.createElement('button');
      videoBtn.id = 'viewerVideoBtn';
      videoBtn.className = 'animation';
      videoBtn.textContent = 'å‹•ç”»ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰';
      videoBtn.disabled = true;
      buttonGroup.appendChild(videoBtn);
      
      // æ–°è¦ä½œæˆãƒªãƒ³ã‚¯
      const newBtn = document.createElement('button');
      newBtn.className = 'secondary';
      newBtn.textContent = 'æ–°è¦ä½œæˆ';
      newBtn.addEventListener('click', () => {
        window.location.href = window.location.pathname;
      });
      buttonGroup.appendChild(newBtn);
      
      // åˆæœŸæç”»
      const points = reconstructFromCoefficients(data);
      drawPoints(rctx, reconCanvas, points);
      updateStatus(`å¾©å…ƒå®Œäº† (K=${data.k.length}, N=${data.n})`);
      
      // ä¿‚æ•°ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ï¼ˆQRã‚«ãƒ¼ãƒ‰ç”Ÿæˆç”¨ï¼‰
      currentCoefficients = data;
      document.getElementById('shareBtn').disabled = false;
      
      // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å†ç”Ÿ
      playBtn.addEventListener('click', () => {
        if (animationId) {
          cancelAnimationFrame(animationId);
          clearTimeout(animationId);
          animationId = null;
        }
        
        animationFrames = generateAnimationFramesFromCoefficients(data, 30);
        
        if (animationFrames.length === 0) {
          updateStatus('ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“');
          return;
        }
        
        currentFrameIndex = 0;
        isPlaying = true;
        videoBtn.disabled = false;
        
        showProgress(true);
        updateStatus(`ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å†ç”Ÿä¸­ (${animationFrames.length}ãƒ•ãƒ¬ãƒ¼ãƒ )`);
        playAnimation();
      });
      
      // å‹•ç”»ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
      videoBtn.addEventListener('click', async () => {
        if (animationFrames.length === 0) {
          // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒæœªç”Ÿæˆã®å ´åˆã¯ç”Ÿæˆ
          animationFrames = generateAnimationFramesFromCoefficients(data, 30);
        }
        
        if (animationFrames.length === 0) {
          alert('ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“');
          return;
        }
        
        isPlaying = false;
        if (animationId) {
          cancelAnimationFrame(animationId);
          clearTimeout(animationId);
          animationId = null;
        }
        
        updateStatus('å‹•ç”»ã‚’ç”Ÿæˆä¸­...');
        showProgress(true);
        setProgress(0);
        
        try {
          const stream = reconCanvas.captureStream(30);
          const mediaRecorder = new MediaRecorder(stream, {
            mimeType: 'video/webm;codecs=vp9',
            videoBitsPerSecond: 5000000
          });
          
          const chunks = [];
          mediaRecorder.ondataavailable = (e) => {
            if (e.data.size > 0) {
              chunks.push(e.data);
            }
          };
          
          mediaRecorder.onstop = () => {
            const blob = new Blob(chunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'fourier_animation.webm';
            link.click();
            URL.revokeObjectURL(url);
            
            updateStatus('å‹•ç”»ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãŒå®Œäº†ã—ã¾ã—ãŸ');
            showProgress(false);
            
            // æœ€çµ‚ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’è¡¨ç¤º
            const finalPoints = reconstructFromCoefficients(data);
            drawPoints(rctx, reconCanvas, finalPoints);
          };
          
          mediaRecorder.start();
          
          for (let i = 0; i < animationFrames.length; i++) {
            const frame = animationFrames[i];
            drawPoints(rctx, reconCanvas, frame.points);
            setProgress(((i + 1) / animationFrames.length) * 100);
            
            const delay = frame.isFinal ? 3000 : 100;
            await new Promise(resolve => setTimeout(resolve, delay));
          }
          
          mediaRecorder.stop();
          
        } catch (error) {
          console.error("Error:", error);
          alert("å‹•ç”»ç”Ÿæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ãƒ–ãƒ©ã‚¦ã‚¶ãŒWebMå½¢å¼ã«å¯¾å¿œã—ã¦ã„ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚");
          updateStatus('å‹•ç”»ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ');
          showProgress(false);
        }
      });
    }
    
    // ============================================
    // åˆæœŸåŒ–
    // ============================================
    
    // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ãƒã‚§ãƒƒã‚¯
    window.addEventListener('load', () => {
      const sharedData = loadFromUrlParams();
      
      if (sharedData) {
        // ãƒ“ãƒ¥ãƒ¼ã‚¢ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã§èµ·å‹•
        initViewerMode(sharedData);
      } else {
        // é€šå¸¸ãƒ¢ãƒ¼ãƒ‰ - shareãƒœã‚¿ãƒ³ã¯å¤‰æ›å¾Œã«æœ‰åŠ¹åŒ–
        document.getElementById('shareBtn').disabled = true;
      }
    });
    
    // ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›æ™‚ã«ä¿‚æ•°ã‚’ä¿å­˜ï¼ˆå…ƒã®processBtnãƒªã‚¹ãƒŠãƒ¼ã‚’æ‹¡å¼µï¼‰
    const originalProcessHandler = document.getElementById('processBtn').onclick;
    document.getElementById('processBtn').addEventListener('click', () => {
      // ãƒ•ãƒ¼ãƒªã‚¨å¤‰æ›å®Ÿè¡Œå¾Œã«ä¿‚æ•°ã‚’è¨ˆç®—
      setTimeout(() => {
        const points3d = generatePoints3d();
        const points2d = generatePoints2d();
        
        if (points2d.length > 0) {
          const K = parseInt(document.getElementById('kValue').value);
          const useMultiStroke = multiStrokeMode;
          const inputPoints = useMultiStroke ? points3d : points2d;
          
          // å…±æœ‰ç”¨ã®ä¿‚æ•°ã‚’å–å¾—ï¼ˆKå€‹ã«åˆ¶é™ã€æœ€å¤§50å€‹ï¼‰
          const shareK = Math.min(K, 50);
          currentCoefficients = getFourierCoefficients(inputPoints, shareK, useMultiStroke);
          
          // shareãƒœã‚¿ãƒ³ã‚’æœ‰åŠ¹åŒ–
          document.getElementById('shareBtn').disabled = false;
        }
      }, 100);
    });
  </script>
</body>
</html>
