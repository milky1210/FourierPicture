<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Fourier Transform Doodle Art</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="alternate" hreflang="ja" href="index.html">
  <link rel="alternate" hreflang="en" href="en.html">
  <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: 'Arial', sans-serif;
      background-color: #f5f5f5;
      padding: 20px;
    }
    h1 {
      text-align: center;
      color: #333;
      margin-bottom: 20px;
    }
    .container {
      display: flex;
      gap: 20px;
      max-width: 1400px;
      margin: 0 auto;
      background-color: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    @media (max-width: 900px) {
      .container {
        flex-direction: column;
      }
    }
    .left-panel, .right-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    .panel-title {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 10px;
      color: #555;
    }
    canvas {
      border: 2px solid #333;
      border-radius: 5px;
      cursor: crosshair;
      background-color: white;
      max-width: 100%;
      height: auto;
    }
    .controls {
      margin-top: 15px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .control-group {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    label {
      font-weight: bold;
      color: #555;
    }
    input[type="number"] {
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
      width: 100px;
    }
    input[type="checkbox"] {
      width: 18px;
      height: 18px;
    }
    button {
      padding: 10px 20px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      font-size: 14px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    button:hover {
      background-color: #45a049;
    }
    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    button.secondary {
      background-color: #2196F3;
    }
    button.secondary:hover {
      background-color: #0b7dda;
    }
    button.clear {
      background-color: #f44336;
    }
    button.clear:hover {
      background-color: #da190b;
    }
    button.animation {
      background-color: #9C27B0;
    }
    button.animation:hover {
      background-color: #7B1FA2;
    }
    button.share {
      background-color: #FF9800;
    }
    button.share:hover {
      background-color: #F57C00;
    }
    .button-group {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.7);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    .modal-content {
      background-color: white;
      padding: 20px;
      border-radius: 10px;
      max-width: 90%;
      max-height: 90%;
      overflow: auto;
      text-align: center;
    }
    .modal-content h2 {
      margin-bottom: 15px;
      color: #333;
    }
    .modal-content canvas {
      border: 1px solid #ccc;
      cursor: default;
    }
    .modal-buttons {
      margin-top: 15px;
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
    }
    .modal-close {
      background-color: #666;
    }
    .modal-close:hover {
      background-color: #555;
    }
    .status {
      font-size: 14px;
      color: #666;
      padding: 10px;
      background-color: #f0f0f0;
      border-radius: 4px;
      min-height: 40px;
    }
    .progress-container {
      width: 100%;
      height: 20px;
      background-color: #e0e0e0;
      border-radius: 10px;
      overflow: hidden;
      margin-top: 5px;
    }
    .progress-bar {
      height: 100%;
      background-color: #9C27B0;
      width: 0%;
      transition: width 0.1s;
    }
    .mode-info {
      font-size: 12px;
      color: #888;
      margin-top: 5px;
    }
    .k-control-wrapper {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .k-input-group {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    input[type="range"] {
      flex: 1;
      min-width: 150px;
    }
    .k-value-display {
      font-weight: bold;
      color: #333;
      min-width: 40px;
      text-align: center;
    }
    .increment-btn {
      padding: 8px 16px;
      background-color: #2196F3;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    .increment-btn:hover {
      background-color: #0b7dda;
    }
    footer {
      text-align: center;
      margin-top: 20px;
      color: #888;
      font-size: 12px;
    }
    footer a {
      color: #2196F3;
      text-decoration: none;
    }
    footer a:hover {
      text-decoration: underline;
    }
    .support-section {
      text-align: center;
      margin-top: 30px;
      padding: 20px;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }
    .support-link {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 20px;
      background: linear-gradient(135deg, #FFDD00 0%, #FBB034 100%);
      color: #000;
      text-decoration: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      transition: transform 0.2s, box-shadow 0.2s;
      box-shadow: 0 2px 8px rgba(251, 176, 52, 0.3);
    }
    .support-link:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(251, 176, 52, 0.4);
      text-decoration: none;
    }
    .coffee-icon {
      font-size: 18px;
    }
    .lang-switch {
      text-align: right;
      margin-bottom: 10px;
    }
    .lang-switch a {
      color: #2196F3;
      text-decoration: none;
    }
    .qr-hint {
      display: block;
      font-size: 11px;
      color: #666;
      margin-top: 8px;
      line-height: 1.4;
      text-align: center;
    }
    .qr-hint.warning {
      color: #e65100;
    }
    .qr-hint.ok {
      color: #2e7d32;
    }
    /* Menu styles */
    .header-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }
    .menu-btn {
      background-color: #607D8B;
      padding: 8px 16px;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .menu-btn:hover {
      background-color: #546E7A;
    }
    .menu-panel {
      display: none;
      position: fixed;
      top: 0;
      right: 0;
      width: 320px;
      max-width: 90%;
      height: 100%;
      background-color: white;
      box-shadow: -2px 0 10px rgba(0,0,0,0.2);
      z-index: 1001;
      overflow-y: auto;
      padding: 20px;
    }
    .menu-panel.open {
      display: block;
    }
    .menu-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
      z-index: 1000;
    }
    .menu-overlay.open {
      display: block;
    }
    .menu-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 10px;
      border-bottom: 2px solid #eee;
    }
    .menu-header h3 {
      margin: 0;
      color: #333;
    }
    .menu-close-btn {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: #666;
      padding: 0;
    }
    .menu-close-btn:hover {
      color: #333;
      background: none;
    }
    .menu-section {
      margin-bottom: 20px;
    }
    .menu-section h4 {
      font-size: 14px;
      color: #555;
      margin-bottom: 10px;
      padding-bottom: 5px;
      border-bottom: 1px solid #eee;
    }
    .menu-item {
      margin-bottom: 15px;
    }
    .menu-item label {
      display: block;
      margin-bottom: 5px;
      font-size: 13px;
    }
    .menu-item input[type="number"],
    .menu-item input[type="range"] {
      width: 100%;
    }
    .menu-item input[type="file"] {
      width: 100%;
      padding: 8px;
      border: 1px dashed #ccc;
      border-radius: 4px;
      cursor: pointer;
    }
    .menu-item button {
      width: 100%;
      margin-bottom: 5px;
    }
    .menu-item .range-value {
      font-size: 12px;
      color: #888;
      text-align: right;
    }
    .saved-works-list {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #eee;
      border-radius: 4px;
    }
    .saved-work-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 10px;
      border-bottom: 1px solid #eee;
    }
    .saved-work-item:last-child {
      border-bottom: none;
    }
    .saved-work-item span {
      font-size: 12px;
      color: #333;
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .saved-work-item button {
      width: auto;
      padding: 4px 8px;
      font-size: 11px;
      margin: 0 2px;
    }
    .saved-work-item .load-btn {
      background-color: #4CAF50;
    }
    .saved-work-item .delete-btn {
      background-color: #f44336;
    }
    .no-saved-works {
      padding: 15px;
      text-align: center;
      color: #888;
      font-size: 13px;
    }
  </style>
</head>
<body>
  <div class="header-bar">
    <div class="lang-switch">
      <a href="index.html">üáØüáµ Êó•Êú¨Ë™û</a>
    </div>
    <button class="menu-btn" id="menuBtn">‚ò∞ Menu</button>
  </div>
  
  <h1>Fourier Transform Doodle Art</h1>
  
  <div class="container">
    <!-- Left Panel: Input -->
    <div class="left-panel">
      <div class="panel-title">Drawing Canvas</div>
      <canvas id="drawCanvas" width="600" height="400"></canvas>
      
      <div class="controls">
        <div class="control-group">
          <label for="multiStrokeMode">
            <input type="checkbox" id="multiStrokeMode" checked> Multi-stroke Mode
          </label>
        </div>
        <div class="mode-info" id="modeInfo">Multi-stroke Mode: Draw multiple lines. Gaps between strokes appear faded.</div>
        
        <div class="k-control-wrapper">
          <label>Fourier Terms K:</label>
          <div class="k-input-group">
            <input type="range" id="kSlider" min="1" max="200" value="10">
            <span class="k-value-display" id="kValueDisplay">10</span>
            <div class="k-button-group">
              <button id="incrementKBtn" class="increment-btn">‚ñ≤</button>
              <button id="decrementKBtn" class="increment-btn">‚ñº</button>
            </div>
          </div>
          <input type="number" id="kValue" value="10" min="1" max="1000" style="display:none;">
        </div>
        
        <div class="button-group">
          <button id="clearBtn" class="clear">Clear</button>
        </div>
        
        <div class="control-group">
          <label for="numFrames">Animation Frames:</label>
          <input type="number" id="numFrames" value="30" min="5" max="100">
        </div>
        
        <div class="button-group">
          <button id="animationBtn" class="animation">Generate Animation</button>
          <button id="downloadVideoBtn" class="animation" disabled>Download GIF</button>
        </div>
      </div>
    </div>
    
    <!-- Right Panel: Output -->
    <div class="right-panel">
      <div class="panel-title">Generated Image</div>
      <canvas id="reconCanvas" width="600" height="400"></canvas>
      
      <div class="controls">
        <div class="status" id="statusText">Draw something and click Transform</div>
        <div class="progress-container" id="progressContainer" style="display: none;">
          <div class="progress-bar" id="progressBar"></div>
        </div>
        <div class="button-group">
          <button id="downloadOutputBtn" class="secondary">Download Output</button>
          <button id="shareBtn" class="share" disabled>Create QR Card</button>
        </div>
        <div id="qrHintText" class="qr-hint"></div>
      </div>
    </div>
  </div>
  
  <!-- QR Card Modal -->
  <div id="shareModal" class="modal-overlay">
    <div class="modal-content">
      <h2>üìú Artifact (Permanent Storage Card)</h2>
      <canvas id="cardCanvas" width="800" height="900"></canvas>
      <div class="modal-buttons">
        <button id="downloadCardBtn" class="secondary">Download Card Image</button>
        <button id="copyUrlBtn" class="secondary">Copy URL</button>
        <button id="closeModalBtn" class="modal-close">Close</button>
      </div>
    </div>
  </div>
  
  <!-- Menu Overlay and Panel -->
  <div class="menu-overlay" id="menuOverlay"></div>
  <div class="menu-panel" id="menuPanel">
    <div class="menu-header">
      <h3>Menu</h3>
      <button class="menu-close-btn" id="menuCloseBtn">&times;</button>
    </div>
    
    <div class="menu-section">
      <h4>üìÅ Import Image</h4>
      <div class="menu-item">
        <label for="svgFileInput">Select SVG file:</label>
        <input type="file" id="svgFileInput" accept=".svg">
      </div>
      <div class="menu-item">
        <label for="svgSampleInterval">Sampling interval (px):</label>
        <input type="range" id="svgSampleInterval" min="1" max="20" value="5">
        <div class="range-value"><span id="svgSampleIntervalValue">5</span>px</div>
      </div>
    </div>
    
    <div class="menu-section">
      <h4>‚öôÔ∏è Parameters</h4>
      <div class="menu-item">
        <label for="menuKValue">Fourier Terms K:</label>
        <input type="number" id="menuKValue" value="10" min="1" max="1000">
      </div>
      <div class="menu-item">
        <label for="menuNumFrames">Animation Frames:</label>
        <input type="number" id="menuNumFrames" value="30" min="5" max="100">
      </div>
      <div class="menu-item">
        <label for="menuPenThreshold">Pen Threshold:</label>
        <input type="range" id="menuPenThreshold" min="0" max="100" value="50">
        <div class="range-value"><span id="menuPenThresholdValue">0.5</span></div>
      </div>
    </div>
    
    <div class="menu-section">
      <h4>üíæ Save / Load Works</h4>
      <div class="menu-item">
        <input type="text" id="saveWorkName" placeholder="Enter work name..." style="width: 100%; padding: 8px; margin-bottom: 5px;">
        <button id="saveWorkBtn" class="secondary">Save Current Work</button>
      </div>
      <div class="menu-item">
        <label>Saved Works:</label>
        <div class="saved-works-list" id="savedWorksList">
          <div class="no-saved-works">No saved works</div>
        </div>
      </div>
    </div>
  </div>
  
  <footer>
    <p>Created by <a href="https://github.com/milky1210" target="_blank">milky1210</a> | <a href="https://github.com/milky1210/FourierPicture" target="_blank">GitHub</a></p>
    <p>First Published: 2025-11-27 (See <a href="https://github.com/milky1210/FourierPicture/commits/main" target="_blank">git history</a> for precise timestamp)</p>
    <div class="support-section">
      <a href="https://buymeacoffee.com/milky1210" target="_blank" rel="noopener noreferrer" class="support-link">
        <span class="coffee-icon">‚òï</span>
        <span>Buy me a coffee if you enjoy this project</span>
      </a>
    </div>
  </footer>
  
  <script>
    // ============================================
    // FFT Implementation (JavaScript)
    // ============================================
    
    class Complex {
      constructor(re, im) {
        this.re = re;
        this.im = im;
      }
      
      add(other) {
        return new Complex(this.re + other.re, this.im + other.im);
      }
      
      sub(other) {
        return new Complex(this.re - other.re, this.im - other.im);
      }
      
      mul(other) {
        return new Complex(
          this.re * other.re - this.im * other.im,
          this.re * other.im + this.im * other.re
        );
      }
      
      scale(s) {
        return new Complex(this.re * s, this.im * s);
      }
      
      abs() {
        return Math.sqrt(this.re * this.re + this.im * this.im);
      }
    }
    
    function dft(input) {
      const N = input.length;
      const output = [];
      
      for (let k = 0; k < N; k++) {
        let sum = new Complex(0, 0);
        for (let n = 0; n < N; n++) {
          const angle = -2 * Math.PI * k * n / N;
          const exp = new Complex(Math.cos(angle), Math.sin(angle));
          sum = sum.add(input[n].mul(exp));
        }
        output.push(sum);
      }
      
      return output;
    }
    
    function fftfreq(N) {
      const freqs = [];
      for (let i = 0; i < N; i++) {
        if (i < Math.floor((N + 1) / 2)) {
          freqs.push(i / N);
        } else {
          freqs.push((i - N) / N);
        }
      }
      return freqs;
    }
    
    function reconstructFourier2d(points, K) {
      const N = points.length;
      if (N === 0) return [];
      
      const z = points.map(p => new Complex(p[0], p[1]));
      const F = dft(z);
      const freqs = fftfreq(N);
      
      const amplitudes = F.map(c => c.abs());
      const indices = Array.from({ length: N }, (_, i) => i);
      indices.sort((a, b) => amplitudes[b] - amplitudes[a]);
      
      const actualK = Math.min(K, N);
      const selectedIndices = indices.slice(0, actualK);
      
      const numOutputPoints = actualK * 5;
      const result = [];
      
      for (let i = 0; i < numOutputPoints; i++) {
        const t = i / numOutputPoints;
        let sum = new Complex(0, 0);
        
        for (const k of selectedIndices) {
          const freq = freqs[k] * N;
          const angle = 2 * Math.PI * freq * t;
          const exp = new Complex(Math.cos(angle), Math.sin(angle));
          sum = sum.add(F[k].scale(1 / N).mul(exp));
        }
        
        result.push([sum.re, sum.im]);
      }
      
      return result;
    }
    
    function reconstructFourier3d(points, K) {
      const N = points.length;
      if (N === 0) return [];
      
      const x = points.map(p => new Complex(p[0], 0));
      const y = points.map(p => new Complex(p[1], 0));
      const pen = points.map(p => new Complex(p[2], 0));
      
      const Fx = dft(x);
      const Fy = dft(y);
      const Fpen = dft(pen);
      const freqs = fftfreq(N);
      
      const amplitudes = [];
      for (let i = 0; i < N; i++) {
        amplitudes.push(Fx[i].abs() + Fy[i].abs() + Fpen[i].abs());
      }
      const indices = Array.from({ length: N }, (_, i) => i);
      indices.sort((a, b) => amplitudes[b] - amplitudes[a]);
      
      const actualK = Math.min(K, N);
      const selectedIndices = indices.slice(0, actualK);
      
      const numOutputPoints = actualK * 5;
      const result = [];
      
      for (let i = 0; i < numOutputPoints; i++) {
        const t = i / numOutputPoints;
        let sumX = new Complex(0, 0);
        let sumY = new Complex(0, 0);
        let sumPen = new Complex(0, 0);
        
        for (const k of selectedIndices) {
          const freq = freqs[k] * N;
          const angle = 2 * Math.PI * freq * t;
          const exp = new Complex(Math.cos(angle), Math.sin(angle));
          sumX = sumX.add(Fx[k].scale(1 / N).mul(exp));
          sumY = sumY.add(Fy[k].scale(1 / N).mul(exp));
          sumPen = sumPen.add(Fpen[k].scale(1 / N).mul(exp));
        }
        
        const penVal = Math.max(0, Math.min(1, sumPen.re));
        result.push([sumX.re, sumY.re, penVal]);
      }
      
      return result;
    }
    
    function generateAnimationFrames(points, numFrames, is3d) {
      const N = points.length;
      if (N === 0) return [];
      if (N < 2) return [{ K: N, points: points, isFinal: true }];
      
      const reconstructFn = is3d ? reconstructFourier3d : reconstructFourier2d;
      
      const kMin = 2;
      const kMax = N;
      
      const kValuesSet = new Set();
      for (let i = 0; i < numFrames; i++) {
        let k;
        if (numFrames === 1) {
          k = kMax;
        } else {
          const t = i / (numFrames - 1);
          const tAdjusted = Math.pow(t, 0.6);
          const logK = Math.log(kMin) + (Math.log(kMax) - Math.log(kMin)) * tAdjusted;
          k = Math.round(Math.exp(logK));
        }
        k = Math.max(kMin, Math.min(k, kMax));
        kValuesSet.add(k);
      }
      
      const kValues = Array.from(kValuesSet).sort((a, b) => a - b);
      
      const frames = [];
      for (const k of kValues) {
        const reconstructed = reconstructFn(points, k);
        frames.push({
          K: k,
          points: reconstructed,
          isFinal: false
        });
      }
      
      const finalPoints = reconstructFn(points, N);
      frames.push({
        K: N,
        points: finalPoints,
        isFinal: true
      });
      
      return frames;
    }

    // ============================================
    // Data Export/Import Functions
    // QR code generation uses qrcode-generator CDN library
    // ============================================
    
    // Round number to specified decimals
    function roundNumber(num, decimals) {
      const factor = Math.pow(10, decimals);
      return Math.round(num * factor) / factor;
    }
    
    // Get Fourier coefficients (limited to K for sharing)
    function getFourierCoefficients(points, K, is3d) {
      const N = points.length;
      if (N === 0) return null;
      
      const actualK = Math.min(K, N);
      
      if (is3d) {
        const x = points.map(p => new Complex(p[0], 0));
        const y = points.map(p => new Complex(p[1], 0));
        const pen = points.map(p => new Complex(p[2], 0));
        
        const Fx = dft(x);
        const Fy = dft(y);
        const Fpen = dft(pen);
        
        // Sort by amplitude
        const amplitudes = [];
        for (let i = 0; i < N; i++) {
          amplitudes.push(Fx[i].abs() + Fy[i].abs() + Fpen[i].abs());
        }
        const indices = Array.from({ length: N }, (_, i) => i);
        indices.sort((a, b) => amplitudes[b] - amplitudes[a]);
        const selectedIndices = indices.slice(0, actualK);
        
        // Coefficient data (Re, Im alternating)
        const coeffX = [];
        const coeffY = [];
        const coeffPen = [];
        
        for (const k of selectedIndices) {
          coeffX.push(roundNumber(Fx[k].re, 3), roundNumber(Fx[k].im, 3));
          coeffY.push(roundNumber(Fy[k].re, 3), roundNumber(Fy[k].im, 3));
          coeffPen.push(roundNumber(Fpen[k].re, 3), roundNumber(Fpen[k].im, 3));
        }
        
        return {
          f: "v(t)=Sum(Re(Fk*exp(i*2*pi*k*t)))",
          n: N,
          k: selectedIndices.map(i => i),
          d: [coeffX, coeffY, coeffPen]
        };
      } else {
        const z = points.map(p => new Complex(p[0], p[1]));
        const F = dft(z);
        
        const amplitudes = F.map(c => c.abs());
        const indices = Array.from({ length: N }, (_, i) => i);
        indices.sort((a, b) => amplitudes[b] - amplitudes[a]);
        const selectedIndices = indices.slice(0, actualK);
        
        const coeffZ = [];
        for (const k of selectedIndices) {
          coeffZ.push(roundNumber(F[k].re, 3), roundNumber(F[k].im, 3));
        }
        
        return {
          f: "z(t)=Sum(Fk*exp(i*2*pi*k*t))",
          n: N,
          k: selectedIndices.map(i => i),
          d: [coeffZ]
        };
      }
    }
    
    // Reconstruct from coefficients
    function reconstructFromCoefficients(data) {
      const N = data.n;
      const K = data.k;
      const is3d = data.d.length === 3;
      const freqs = fftfreq(N);
      
      const numOutputPoints = K.length * 5;
      const result = [];
      
      if (is3d) {
        const coeffX = data.d[0];
        const coeffY = data.d[1];
        const coeffPen = data.d[2];
        
        for (let i = 0; i < numOutputPoints; i++) {
          const t = i / numOutputPoints;
          let sumX = new Complex(0, 0);
          let sumY = new Complex(0, 0);
          let sumPen = new Complex(0, 0);
          
          for (let j = 0; j < K.length; j++) {
            const k = K[j];
            const freq = freqs[k] * N;
            const angle = 2 * Math.PI * freq * t;
            const exp = new Complex(Math.cos(angle), Math.sin(angle));
            
            const Fxk = new Complex(coeffX[j * 2], coeffX[j * 2 + 1]);
            const Fyk = new Complex(coeffY[j * 2], coeffY[j * 2 + 1]);
            const Fpenk = new Complex(coeffPen[j * 2], coeffPen[j * 2 + 1]);
            
            sumX = sumX.add(Fxk.scale(1 / N).mul(exp));
            sumY = sumY.add(Fyk.scale(1 / N).mul(exp));
            sumPen = sumPen.add(Fpenk.scale(1 / N).mul(exp));
          }
          
          const penVal = Math.max(0, Math.min(1, sumPen.re));
          result.push([sumX.re, sumY.re, penVal]);
        }
      } else {
        const coeffZ = data.d[0];
        
        for (let i = 0; i < numOutputPoints; i++) {
          const t = i / numOutputPoints;
          let sum = new Complex(0, 0);
          
          for (let j = 0; j < K.length; j++) {
            const k = K[j];
            const freq = freqs[k] * N;
            const angle = 2 * Math.PI * freq * t;
            const exp = new Complex(Math.cos(angle), Math.sin(angle));
            
            const Fk = new Complex(coeffZ[j * 2], coeffZ[j * 2 + 1]);
            sum = sum.add(Fk.scale(1 / N).mul(exp));
          }
          
          result.push([sum.re, sum.im]);
        }
      }
      
      return result;
    }
    
    // Efficient binary encoding (quantize coefficients to 16-bit integers)
    function encodeDataCompact(data) {
      const n = data.n;
      const k = data.k;
      const d = data.d;
      const is3d = d.length === 3;
      
      // Header: version(1byte) + flags(1byte) + N(2bytes) + K count(2bytes)
      const kCount = k.length;
      const headerSize = 6;
      
      // Bytes per coefficient: index(2bytes) + Re(2bytes) + Im(2bytes) = 6bytes per freq
      // 3D: 4bytes(Re+Im) * 3 axes = 12bytes per freq, 2D: 4bytes per freq
      const coeffBytesPerFreq = is3d ? 12 : 4;
      const totalBytes = headerSize + kCount * (2 + coeffBytesPerFreq);
      
      const buffer = new ArrayBuffer(totalBytes);
      const view = new DataView(buffer);
      
      let offset = 0;
      view.setUint8(offset++, 2); // version 2 (compact)
      view.setUint8(offset++, is3d ? 1 : 0); // flags
      view.setUint16(offset, n, true); offset += 2;
      view.setUint16(offset, kCount, true); offset += 2;
      
      // Calculate scale (find max value of coefficients)
      let maxVal = 0;
      for (const arr of d) {
        for (const v of arr) {
          maxVal = Math.max(maxVal, Math.abs(v));
        }
      }
      const scale = maxVal > 0 ? 32000 / maxVal : 1;
      
      // Save scale value (add 4 bytes as float32)
      const newTotalBytes = totalBytes + 4;
      const newBuffer = new ArrayBuffer(newTotalBytes);
      const newView = new DataView(newBuffer);
      
      // Copy header
      offset = 0;
      newView.setUint8(offset++, 2);
      newView.setUint8(offset++, is3d ? 1 : 0);
      newView.setUint16(offset, n, true); offset += 2;
      newView.setUint16(offset, kCount, true); offset += 2;
      newView.setFloat32(offset, scale, true); offset += 4;
      
      // Coefficient data
      for (let i = 0; i < kCount; i++) {
        newView.setUint16(offset, k[i], true); offset += 2;
        
        for (let axis = 0; axis < d.length; axis++) {
          const re = Math.round(d[axis][i * 2] * scale);
          const im = Math.round(d[axis][i * 2 + 1] * scale);
          newView.setInt16(offset, re, true); offset += 2;
          newView.setInt16(offset, im, true); offset += 2;
        }
      }
      
      // Convert to Uint8Array and Base64 encode
      const bytes = new Uint8Array(newBuffer);
      const binaryStr = Array.from(bytes, byte => String.fromCharCode(byte)).join('');
      return btoa(binaryStr);
    }
    
    // Decode compact data
    function decodeDataCompact(base64Str) {
      try {
        const binaryStr = atob(base64Str);
        const bytes = new Uint8Array(binaryStr.length);
        for (let i = 0; i < binaryStr.length; i++) {
          bytes[i] = binaryStr.charCodeAt(i);
        }
        const view = new DataView(bytes.buffer);
        
        let offset = 0;
        const version = view.getUint8(offset++);
        const flags = view.getUint8(offset++);
        const n = view.getUint16(offset, true); offset += 2;
        const kCount = view.getUint16(offset, true); offset += 2;
        const scale = view.getFloat32(offset, true); offset += 4;
        
        const is3d = (flags & 1) === 1;
        const k = [];
        const d = is3d ? [[], [], []] : [[]];
        
        for (let i = 0; i < kCount; i++) {
          k.push(view.getUint16(offset, true)); offset += 2;
          
          for (let axis = 0; axis < d.length; axis++) {
            const re = view.getInt16(offset, true) / scale; offset += 2;
            const im = view.getInt16(offset, true) / scale; offset += 2;
            d[axis].push(re, im);
          }
        }
        
        return { n, k, d };
      } catch (e) {
        console.error('Failed to decode compact data:', e);
        return null;
      }
    }
    
    // Encode data to Base64 (legacy format, kept for compatibility)
    function encodeDataToBase64(data) {
      const jsonStr = JSON.stringify(data);
      // UTF-8 compatible Base64 encoding
      const utf8Bytes = new TextEncoder().encode(jsonStr);
      const binaryStr = Array.from(utf8Bytes, byte => String.fromCharCode(byte)).join('');
      return btoa(binaryStr);
    }
    
    // Decode data from Base64 (supports multiple formats)
    function decodeDataFromBase64(base64Str) {
      try {
        const binaryStr = atob(base64Str);
        const bytes = new Uint8Array(binaryStr.length);
        for (let i = 0; i < binaryStr.length; i++) {
          bytes[i] = binaryStr.charCodeAt(i);
        }
        
        // Check for new format (ASCII metadata + binary)
        // First 2 bytes = ASCII data length
        if (bytes.length > 2) {
          const asciiLen = new DataView(bytes.buffer).getUint16(0, true);
          if (asciiLen < bytes.length && asciiLen < 1000) {
            try {
              const asciiPart = new TextDecoder().decode(bytes.slice(2, 2 + asciiLen));
              if (asciiPart.includes("UNIVERSAL DECODER")) {
                // New format detected - decode binary part
                const binaryPart = bytes.slice(2 + asciiLen);
                const view = new DataView(binaryPart.buffer, binaryPart.byteOffset);
                let offset = 0;
                
                // Compact format decode
                const version = view.getUint8(offset++);
                if (version === 2) {
                  const flags = view.getUint8(offset++);
                  const n = view.getUint16(offset, true); offset += 2;
                  const kCount = view.getUint16(offset, true); offset += 2;
                  const scale = view.getFloat32(offset, true); offset += 4;
                  
                  const is3d = (flags & 1) === 1;
                  const k = [];
                  const d = is3d ? [[], [], []] : [[]];
                  
                  for (let i = 0; i < kCount; i++) {
                    k.push(view.getUint16(offset, true)); offset += 2;
                    
                    for (let axis = 0; axis < d.length; axis++) {
                      const re = view.getInt16(offset, true) / scale; offset += 2;
                      const im = view.getInt16(offset, true) / scale; offset += 2;
                      d[axis].push(re, im);
                    }
                  }
                  
                  return { n, k, d };
                }
              }
            } catch (e) {
              // ASCII parsing failed - try next method
            }
          }
        }
        
        // Check for compact format (version=2)
        if (bytes[0] === 2) {
          return decodeDataCompact(base64Str);
        }
        
        // Legacy format (JSON)
        const jsonStr = new TextDecoder().decode(bytes);
        return JSON.parse(jsonStr);
      } catch (e) {
        console.error('Failed to decode data:', e);
        return null;
      }
    }
    
    // Generate share URL (with ASCII decoder metadata + compact binary)
    function generateShareUrl(coefficients) {
      const encoded = encodeDataCompact(coefficients);
      
      // Embed decoder method in QR data as ASCII text
      // UNIVERSAL DECODER header + binary data
      const decoderInfo = "[UNIVERSAL DECODER: FOURIER STROKE]\n" +
                         "Formula: v(t)=Sum(Re(F[k]*exp(i*2*pi*k*t)))\n" +
                         "Range: t=0.0...1.0\n" +
                         "Target: X,Y,Pen axes independently\n" +
                         "Draw: Plot(x(t),y(t)) where pen(t)>0.5\n" +
                         "Data:";
      
      // Combine ASCII data + binary data as Base64
      const asciiBytes = new TextEncoder().encode(decoderInfo);
      const binaryBytes = new Uint8Array(atob(encoded).split('').map(c => c.charCodeAt(0)));
      
      // Combined: ASCII data length(2bytes) + ASCII data + binary data
      const combined = new ArrayBuffer(2 + asciiBytes.length + binaryBytes.length);
      const combinedView = new DataView(combined);
      
      combinedView.setUint16(0, asciiBytes.length, true);
      
      // Copy ASCII and binary data
      const combinedBytes = new Uint8Array(combined);
      combinedBytes.set(asciiBytes, 2);
      combinedBytes.set(binaryBytes, 2 + asciiBytes.length);
      
      // Base64 encode (Prevent stack overflow)
      let binary = '';
      const len = combinedBytes.byteLength;
      const chunkSize = 0x8000; // 32k
      for (let i = 0; i < len; i += chunkSize) {
        const chunk = combinedBytes.subarray(i, Math.min(i + chunkSize, len));
        binary += String.fromCharCode.apply(null, chunk);
      }
      const finalEncoded = btoa(binary);
      
      const baseUrl = window.location.origin + window.location.pathname;
      return baseUrl + '?d=' + encodeURIComponent(finalEncoded);
    }
    
    // Load data from URL params
    function loadFromUrlParams() {
      const urlParams = new URLSearchParams(window.location.search);
      const dataParam = urlParams.get('d');
      
      if (dataParam) {
        try {
          const decoded = decodeDataFromBase64(decodeURIComponent(dataParam));
          if (decoded && decoded.d && decoded.n && decoded.k) {
            return decoded;
          }
        } catch (e) {
          console.error('Failed to load data from URL:', e);
        }
      }
      return null;
    }
    
    // QR version capacity table (alphanumeric capacity for error correction level M)
    const QR_VERSION_CAPACITY = [
      { version: 1, capacity: 20 },
      { version: 2, capacity: 38 },
      { version: 3, capacity: 61 },
      { version: 4, capacity: 90 },
      { version: 5, capacity: 122 },
      { version: 6, capacity: 154 },
      { version: 7, capacity: 178 },
      { version: 8, capacity: 221 },
      { version: 9, capacity: 262 },
      { version: 10, capacity: 311 },
      { version: 15, capacity: 586 },
      { version: 20, capacity: 969 },
      { version: 25, capacity: 1370 },
      { version: 30, capacity: 1852 },
      { version: 35, capacity: 2324 },
      { version: 40, capacity: 4296 }
    ];
    
    // Estimate URL length from K value (compact binary format)
    function estimateUrlLength(k, is3d = true) {
      // Compact format: header 10bytes + K * (2 + 4*axes) bytes
      // 3D: 10 + K * (2 + 12) = 10 + 14K bytes
      // 2D: 10 + K * (2 + 4) = 10 + 6K bytes
      const binarySize = is3d ? (10 + k * 14) : (10 + k * 6);
      // Base64 is ~1.37x larger, URL encoding adds a bit more
      const base64Size = Math.ceil(binarySize * 1.37);
      const baseUrlSize = 80; // base URL + parameter name
      return baseUrlSize + base64Size;
    }
    
    // Get QR code info for K value
    function getQRInfoForK(k, is3d = true) {
      const estimatedLength = estimateUrlLength(k, is3d);
      
      // Max versions for easy smartphone scanning
      const easyReadMaxVersion = 10; // Version 10 or below is easy to scan
      const possibleMaxVersion = 25; // Version 25 or below is possible with most apps
      
      let recommendedVersion = null;
      let isEasyRead = false;
      let isPossible = false;
      
      for (const info of QR_VERSION_CAPACITY) {
        if (estimatedLength <= info.capacity) {
          recommendedVersion = info.version;
          isEasyRead = info.version <= easyReadMaxVersion;
          isPossible = info.version <= possibleMaxVersion;
          break;
        }
      }
      
      return {
        estimatedLength,
        recommendedVersion,
        isEasyRead,
        isPossible,
        maxEasyK: findMaxKForVersion(easyReadMaxVersion, is3d),
        maxPossibleK: findMaxKForVersion(possibleMaxVersion, is3d)
      };
    }
    
    // Calculate max K for a given version
    function findMaxKForVersion(maxVersion, is3d = true) {
      const capacity = QR_VERSION_CAPACITY.find(v => v.version >= maxVersion)?.capacity || 4296;
      // Reverse: capacity ‚âà 80 + 1.37 * (10 + bytesPerK * k)
      // 3D: bytesPerK = 14, 2D: bytesPerK = 6
      const bytesPerK = is3d ? 14 : 6;
      const maxK = Math.floor(((capacity - 80) / 1.37 - 10) / bytesPerK);
      return Math.max(1, maxK);
    }
    
    // Generate QR code and render to canvas (supports large K values)
    function generateQRCode(url, targetCanvas, baseCellSize) {
      try {
        const dataLength = url.length;
        
        // Adjust error correction and cell size based on data length
        let errorCorrectionLevel = 'M';
        let cellSize = baseCellSize;
        
        // Gradually reduce cell size to make QR code smaller
        if (dataLength > 500) {
          cellSize = Math.max(4, baseCellSize - 1);
        }
        if (dataLength > 1000) {
          cellSize = Math.max(3, baseCellSize - 2);
          errorCorrectionLevel = 'L'; // Lower error correction for capacity
        }
        if (dataLength > 2000) {
          cellSize = Math.max(2, baseCellSize - 3);
        }
        if (dataLength > 3000) {
          cellSize = Math.max(1, baseCellSize - 4);
        }
        
        const qr = qrcode(0, errorCorrectionLevel);
        qr.addData(url);
        qr.make();
        
        const ctx = targetCanvas.getContext('2d');
        const moduleCount = qr.getModuleCount();
        const margin = cellSize * 2;
        const size = moduleCount * cellSize + margin * 2;
        
        targetCanvas.width = size;
        targetCanvas.height = size;
        
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, size, size);
        
        for (let row = 0; row < moduleCount; row++) {
          for (let col = 0; col < moduleCount; col++) {
            ctx.fillStyle = qr.isDark(row, col) ? '#000000' : '#ffffff';
            ctx.fillRect(
              col * cellSize + margin,
              row * cellSize + margin,
              cellSize,
              cellSize
            );
          }
        }
        
        return { width: size, height: size, version: Math.ceil((moduleCount - 17) / 4), moduleCount };
      } catch (e) {
        console.error('QR code generation failed:', e);
        return null;
      }
    }
    
    // Current coefficient data (for sharing)
    let currentCoefficients = null;

    // ============================================
    // UI
    // ============================================
    
    const canvas = document.getElementById('drawCanvas');
    const ctx = canvas.getContext('2d');
    let drawing = false;
    
    let currentStroke = [];
    let strokes = [];
    
    let multiStrokeMode = true;

    // Sampling control parameters
    const SAMPLING_FPS_LIMIT = 60; // FPS limit
    const SAMPLING_MIN_INTERVAL = 1000 / SAMPLING_FPS_LIMIT; // Minimum sampling interval (ms)
    const SAMPLING_MIN_DISTANCE = 2; // Minimum distance (pixels)
    const COLLINEARITY_THRESHOLD = 0.5; // Collinearity threshold (pixels)
    let lastSampleTime = 0;

    // Calculate distance between two points
    function getDistance(p1, p2) {
      const dx = p2[0] - p1[0];
      const dy = p2[1] - p1[1];
      return Math.sqrt(dx * dx + dy * dy);
    }

    // Calculate perpendicular distance from point p2 to line p1-p3
    function getPointToLineDistance(p1, p2, p3) {
      const dx = p3[0] - p1[0];
      const dy = p3[1] - p1[1];
      const lineLength = Math.sqrt(dx * dx + dy * dy);
      if (lineLength === 0) return getDistance(p1, p2);
      
      // Perpendicular distance from p2 to line p1-p3
      const cross = Math.abs((p2[0] - p1[0]) * dy - (p2[1] - p1[1]) * dx);
      return cross / lineLength;
    }

    // Remove redundant collinear points from stroke on stroke end
    function simplifyStroke(stroke) {
      if (stroke.length <= 2) return stroke;
      
      const result = [stroke[0]];
      
      for (let i = 1; i < stroke.length - 1; i++) {
        const prev = result[result.length - 1];
        const curr = stroke[i];
        const next = stroke[i + 1];
        
        // Keep point if it's far enough from the line
        const distance = getPointToLineDistance(prev, curr, next);
        if (distance > COLLINEARITY_THRESHOLD) {
          result.push(curr);
        }
      }
      
      // Always add the last point
      result.push(stroke[stroke.length - 1]);
      
      return result;
    }

    const reconCanvas = document.getElementById('reconCanvas');
    const rctx = reconCanvas.getContext('2d', { willReadFrequently: true });
    
    let animationFrames = [];
    let currentFrameIndex = 0;
    let isPlaying = false;
    let animationId = null;

    function initCanvas(context, canvasElement) {
      context.fillStyle = 'white';
      context.fillRect(0, 0, canvasElement.width, canvasElement.height);
    }

    function updateStatus(text) {
      document.getElementById('statusText').textContent = text;
    }

    function showProgress(show) {
      document.getElementById('progressContainer').style.display = show ? 'block' : 'none';
    }

    function setProgress(percent) {
      document.getElementById('progressBar').style.width = percent + '%';
    }

    function redrawInputCanvas() {
      initCanvas(ctx, canvas);
      
      for (const stroke of strokes) {
        if (stroke.length > 0) {
          ctx.beginPath();
          ctx.moveTo(stroke[0][0], stroke[0][1]);
          for (let i = 1; i < stroke.length; i++) {
            ctx.lineTo(stroke[i][0], stroke[i][1]);
          }
          ctx.strokeStyle = 'black';
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      }
      
      if (currentStroke.length > 0) {
        ctx.beginPath();
        ctx.moveTo(currentStroke[0][0], currentStroke[0][1]);
        for (let i = 1; i < currentStroke.length; i++) {
          ctx.lineTo(currentStroke[i][0], currentStroke[i][1]);
        }
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }

    function generatePoints3d() {
      const allStrokes = [...strokes];
      if (currentStroke.length > 0) {
        allStrokes.push(currentStroke);
      }
      
      if (allStrokes.length === 0) return [];
      
      const result = [];
      
      for (let s = 0; s < allStrokes.length; s++) {
        const stroke = allStrokes[s];
        
        if (s > 0 && result.length > 0 && stroke.length > 0) {
          const lastPoint = result[result.length - 1];
          const firstPoint = stroke[0];
          
          const dist = Math.sqrt(Math.pow(firstPoint[0] - lastPoint[0], 2) + Math.pow(firstPoint[1] - lastPoint[1], 2));
          const numInterp = Math.floor(dist / 10) + 1;
          for (let i = 1; i <= numInterp; i++) {
            const t = i / numInterp;
            const x = lastPoint[0] + (firstPoint[0] - lastPoint[0]) * t;
            const y = lastPoint[1] + (firstPoint[1] - lastPoint[1]) * t;
            result.push([x, y, 0]);
          }
        }
        
        for (const pt of stroke) {
          result.push([pt[0], pt[1], 1]);
        }
      }
      
      if (result.length > 0) {
        const lastPoint = result[result.length - 1];
        const firstPoint = result[0];
        
        const dist = Math.sqrt(Math.pow(firstPoint[0] - lastPoint[0], 2) + Math.pow(firstPoint[1] - lastPoint[1], 2));
        const numInterp = Math.floor(dist / 10) + 1;
        for (let i = 1; i <= numInterp; i++) {
          const t = i / numInterp;
          const x = lastPoint[0] + (firstPoint[0] - lastPoint[0]) * t;
          const y = lastPoint[1] + (firstPoint[1] - lastPoint[1]) * t;
          result.push([x, y, 0]);
        }
      }
      
      return result;
    }

    function generatePoints2d() {
      const allStrokes = [...strokes];
      if (currentStroke.length > 0) {
        allStrokes.push(currentStroke);
      }
      
      const result = [];
      for (const stroke of allStrokes) {
        for (const pt of stroke) {
          result.push([pt[0], pt[1]]);
        }
      }
      return result;
    }

    initCanvas(ctx, canvas);
    initCanvas(rctx, reconCanvas);

    document.getElementById('multiStrokeMode').addEventListener('change', (e) => {
      multiStrokeMode = e.target.checked;
      const modeInfo = document.getElementById('modeInfo');
      if (multiStrokeMode) {
        modeInfo.textContent = 'Multi-stroke Mode: Draw multiple lines. Gaps between strokes appear faded.';
      } else {
        modeInfo.textContent = 'Single-stroke Mode: Canvas resets on each new stroke';
      }
    });

    // K value controls - sync slider and display
    const kSlider = document.getElementById('kSlider');
    const kValue = document.getElementById('kValue');
    const kValueDisplay = document.getElementById('kValueDisplay');
    const incrementKBtn = document.getElementById('incrementKBtn');

    // Auto-execute Fourier transform
    function autoTransform() {
      const points2d = generatePoints2d();
      const points3d = generatePoints3d();
      
      if (points2d.length === 0) {
        return; // Do nothing if no drawing
      }
      
      const K = parseInt(kValue.value);
      if (isNaN(K) || K < 1) {
        return;
      }

      const useMultiStroke = multiStrokeMode;
      const inputPoints = useMultiStroke ? points3d : points2d;
      
      try {
        let result;
        if (useMultiStroke) {
          result = reconstructFourier3d(inputPoints, K);
        } else {
          result = reconstructFourier2d(inputPoints, K);
        }
        
        drawPoints(rctx, reconCanvas, result);
        const strokeInfo = useMultiStroke ? `, strokes: ${strokes.length}` : '';
        updateStatus(`Transform complete (K=${K}, points: ${inputPoints.length}${strokeInfo})`);
        
        // Update QR hint
        updateQRHint();
        
        // Calculate coefficients and enable share button
        currentCoefficients = getFourierCoefficients(inputPoints, K, useMultiStroke);
        document.getElementById('shareBtn').disabled = false;
      } catch (error) {
        console.error("Error:", error);
      }
    }

    // Slider change
    kSlider.addEventListener('input', (e) => {
      const value = e.target.value;
      kValue.value = value;
      kValueDisplay.textContent = value;
      autoTransform();
    });

    // +1 button click
    incrementKBtn.addEventListener('click', () => {
      let currentK = parseInt(kValue.value) || 10;
      currentK = Math.min(currentK + 1, 1000); // Max 1000
      kValue.value = currentK;
      kSlider.value = Math.min(currentK, 200); // Slider max is 200
      kValueDisplay.textContent = currentK;
      autoTransform();
    });

    // -1 button click
    const decrementKBtn = document.getElementById('decrementKBtn');
    decrementKBtn.addEventListener('click', () => {
      let currentK = parseInt(kValue.value) || 10;
      currentK = Math.max(currentK - 1, 1); // Min 1
      kValue.value = currentK;
      kSlider.value = Math.min(currentK, 200); // Slider max is 200
      kValueDisplay.textContent = currentK;
      autoTransform();
    });

    // Direct number input change (just in case)
    kValue.addEventListener('change', (e) => {
      const value = parseInt(e.target.value) || 10;
      const clampedValue = Math.max(1, Math.min(value, 1000));
      kValue.value = clampedValue;
      kSlider.value = Math.min(clampedValue, 200);
      kValueDisplay.textContent = clampedValue;
      autoTransform();
    });

    canvas.addEventListener('mousedown', (e) => {
      drawing = true;
      lastSampleTime = performance.now();
      
      if (!multiStrokeMode) {
        strokes = [];
        currentStroke = [];
        initCanvas(ctx, canvas);
      }
      
      currentStroke = [];
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top) * scaleY;
      currentStroke.push([x, y]);
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 2;
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!drawing) return;
      
      // FPS limit check
      const now = performance.now();
      if (now - lastSampleTime < SAMPLING_MIN_INTERVAL) return;
      
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top) * scaleY;
      
      // Minimum distance check
      if (currentStroke.length > 0) {
        const lastPoint = currentStroke[currentStroke.length - 1];
        if (getDistance(lastPoint, [x, y]) < SAMPLING_MIN_DISTANCE) return;
      }
      
      lastSampleTime = now;
      currentStroke.push([x, y]);
      ctx.lineTo(x, y);
      ctx.stroke();
    });

    canvas.addEventListener('mouseup', () => {
      if (drawing && currentStroke.length > 0) {
        // Simplify stroke by removing redundant collinear points
        const simplified = simplifyStroke(currentStroke);
        strokes.push(simplified);
        currentStroke = [];
        // Auto-execute Fourier transform
        autoTransform();
      }
      drawing = false;
    });

    canvas.addEventListener('mouseleave', () => {
      if (drawing && currentStroke.length > 0) {
        // Simplify stroke by removing redundant collinear points
        const simplified = simplifyStroke(currentStroke);
        strokes.push(simplified);
        currentStroke = [];
        // Auto-execute Fourier transform
        autoTransform();
      }
      drawing = false;
    });

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      drawing = true;
      lastSampleTime = performance.now();
      
      if (!multiStrokeMode) {
        strokes = [];
        currentStroke = [];
        initCanvas(ctx, canvas);
      }
      
      currentStroke = [];
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const touch = e.touches[0];
      const x = (touch.clientX - rect.left) * scaleX;
      const y = (touch.clientY - rect.top) * scaleY;
      currentStroke.push([x, y]);
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 2;
    });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (!drawing) return;
      
      // FPS limit check
      const now = performance.now();
      if (now - lastSampleTime < SAMPLING_MIN_INTERVAL) return;
      
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const touch = e.touches[0];
      const x = (touch.clientX - rect.left) * scaleX;
      const y = (touch.clientY - rect.top) * scaleY;
      
      // Minimum distance check
      if (currentStroke.length > 0) {
        const lastPoint = currentStroke[currentStroke.length - 1];
        if (getDistance(lastPoint, [x, y]) < SAMPLING_MIN_DISTANCE) return;
      }
      
      lastSampleTime = now;
      currentStroke.push([x, y]);
      ctx.lineTo(x, y);
      ctx.stroke();
    });

    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      if (drawing && currentStroke.length > 0) {
        // Simplify stroke by removing redundant collinear points
        const simplified = simplifyStroke(currentStroke);
        strokes.push(simplified);
        currentStroke = [];
        // Auto-execute Fourier transform
        autoTransform();
      }
      drawing = false;
    });

    const PEN_THRESHOLD = 0.5;
    
    function drawPoints3d(context, canvasEl, pts) {
      initCanvas(context, canvasEl);
      if (pts.length < 2) return;
      
      for (let i = 1; i < pts.length; i++) {
        const x0 = pts[i-1][0];
        const y0 = pts[i-1][1];
        const pen0 = pts[i-1][2];
        const x1 = pts[i][0];
        const y1 = pts[i][1];
        const pen1 = pts[i][2];
        
        const penAvg = (pen0 + pen1) / 2;
        
        if (penAvg < PEN_THRESHOLD) continue;
        
        const alpha = (penAvg - PEN_THRESHOLD) / (1 - PEN_THRESHOLD);
        
        context.beginPath();
        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.strokeStyle = `rgba(255, 0, 0, ${alpha})`;
        context.lineWidth = 2;
        context.stroke();
      }
    }

    function drawPoints2d(context, canvasEl, pts, color = 'red') {
      initCanvas(context, canvasEl);
      if (pts.length > 0) {
        context.beginPath();
        context.moveTo(pts[0][0], pts[0][1]);
        for (let i = 1; i < pts.length; i++) {
          context.lineTo(pts[i][0], pts[i][1]);
        }
        context.strokeStyle = color;
        context.lineWidth = 2;
        context.stroke();
      }
    }

    function drawPoints(context, canvasEl, pts) {
      if (pts.length === 0) return;
      
      if (pts[0].length === 3) {
        drawPoints3d(context, canvasEl, pts);
      } else {
        drawPoints2d(context, canvasEl, pts);
      }
    }

    // Update QR hint display (called after Fourier transform)
    function updateQRHint() {
      const k = parseInt(document.getElementById('kValue').value) || 10;
      const is3d = multiStrokeMode;
      const info = getQRInfoForK(k, is3d);
      const hintText = document.getElementById('qrHintText');
      
      if (info.isEasyRead) {
        hintText.className = 'qr-hint ok';
        hintText.textContent = `üí° K=${k}: QR scan optimal (Ver.${info.recommendedVersion})`;
      } else if (info.isPossible) {
        hintText.className = 'qr-hint warning';
        hintText.textContent = `üí° K=${k}: QR scannable. K‚â§${info.maxEasyK} more reliable`;
      } else {
        hintText.className = 'qr-hint warning';
        hintText.textContent = `üí° K=${k}: QR large. K‚â§${info.maxPossibleK} recommended`;
      }
    }

    document.getElementById('clearBtn').addEventListener('click', () => {
      strokes = [];
      currentStroke = [];
      animationFrames = [];
      if (animationId) {
        cancelAnimationFrame(animationId);
        clearTimeout(animationId);
        animationId = null;
      }
      isPlaying = false;
      initCanvas(ctx, canvas);
      initCanvas(rctx, reconCanvas);
      document.getElementById('downloadVideoBtn').disabled = true;
      updateStatus('Draw something and click Transform');
    });

    document.getElementById('animationBtn').addEventListener('click', () => {
      const points2d = generatePoints2d();
      const points3d = generatePoints3d();
      
      if (points2d.length === 0) {
        alert("Please draw something on the canvas first");
        return;
      }
      
      const numFrames = parseInt(document.getElementById('numFrames').value);
      if (isNaN(numFrames) || numFrames < 5) {
        alert("Frame count must be at least 5");
        return;
      }

      if (animationId) {
        cancelAnimationFrame(animationId);
        clearTimeout(animationId);
        animationId = null;
      }

      updateStatus('Generating animation...');
      showProgress(true);
      setProgress(0);

      const useMultiStroke = multiStrokeMode;
      const inputPoints = useMultiStroke ? points3d : points2d;

      setTimeout(() => {
        try {
          animationFrames = generateAnimationFrames(inputPoints, numFrames, useMultiStroke);
          
          if (animationFrames.length === 0) {
            updateStatus('No animation data');
            showProgress(false);
            return;
          }
          
          currentFrameIndex = 0;
          isPlaying = true;
          document.getElementById('downloadVideoBtn').disabled = false;
          
          updateStatus(`Playing animation (${animationFrames.length} frames)`);
          
          playAnimation();
          
        } catch (error) {
          console.error("Error:", error);
          alert("An error occurred: " + error.message);
          updateStatus('Error occurred');
          showProgress(false);
        }
      }, 10);
    });

    function playAnimation() {
      if (!isPlaying || animationFrames.length === 0) return;
      
      const frame = animationFrames[currentFrameIndex];
      drawPoints(rctx, reconCanvas, frame.points);
      
      const progress = ((currentFrameIndex + 1) / animationFrames.length) * 100;
      setProgress(progress);
      
      if (frame.isFinal) {
        updateStatus(`Complete! K = ${frame.K} (all components)`);
      } else {
        updateStatus(`K = ${frame.K} (Frame ${currentFrameIndex + 1}/${animationFrames.length})`);
      }
      
      currentFrameIndex++;
      if (currentFrameIndex >= animationFrames.length) {
        currentFrameIndex = 0;
      }
      
      const delay = frame.isFinal ? 3000 : 100;
      
      animationId = setTimeout(() => {
        requestAnimationFrame(playAnimation);
      }, delay);
    }

    document.getElementById('downloadVideoBtn').addEventListener('click', async () => {
      if (animationFrames.length === 0) {
        alert("Please generate an animation first");
        return;
      }

      isPlaying = false;
      if (animationId) {
        cancelAnimationFrame(animationId);
        clearTimeout(animationId);
        animationId = null;
      }

      updateStatus('Generating GIF...');
      showProgress(true);
      setProgress(0);

      try {
        updateStatus('Generating GIF...');
        
        const gif = new GIF({
          quality: 10,
          width: reconCanvas.width,
          height: reconCanvas.height,
          debug: true,
          workerScript: 'https://cdn.jsdelivr.net/npm/gif.js@0.2.0/dist/gif.worker.js'
        });
        
        console.log('Adding frames to GIF...');
        
        // Add each frame
        for (let i = 0; i < animationFrames.length; i++) {
          const frame = animationFrames[i];
          drawPoints(rctx, reconCanvas, frame.points);
          
          const delay = frame.isFinal ? 3000 : 100;
          gif.addFrame(reconCanvas, {copy: true, delay: delay});
          
          setProgress(((i + 1) / animationFrames.length) * 30);
        }
        
        console.log(`Added ${animationFrames.length} frames`);
        updateStatus('Encoding GIF...');
        
        let renderCompleted = false;
        
        gif.on('finished', (blob) => {
          console.log('GIF rendering finished, blob size:', blob.size);
          renderCompleted = true;
          
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = 'fourier_animation.gif';
          link.click();
          
          setTimeout(() => {
            URL.revokeObjectURL(url);
          }, 100);
          
          updateStatus('GIF download complete');
          showProgress(false);
          
          isPlaying = true;
          playAnimation();
        });
        
        gif.on('progress', (progress) => {
          console.log('GIF encoding progress:', progress);
          setProgress(30 + progress * 70);
        });
        
        gif.on('abort', () => {
          console.log('GIF rendering aborted');
          alert('GIF generation was aborted');
          updateStatus('GIF generation aborted');
          showProgress(false);
          isPlaying = true;
          playAnimation();
        });
        
        console.log('Starting GIF render...');
        gif.render();
        
        // Set 30 second timeout
        setTimeout(() => {
          if (!renderCompleted) {
            console.log('GIF rendering timeout');
            gif.abort();
            alert('GIF generation timed out. Please reduce the number of frames.');
            updateStatus('GIF generation timeout');
            showProgress(false);
            isPlaying = true;
            playAnimation();
          }
        }, 30000);
        
      } catch (error) {
        console.error("Error:", error);
        
        alert("Error generating GIF: " + error.message);
        updateStatus('GIF generation failed');
        showProgress(false);
        
        isPlaying = true;
        playAnimation();
      }
    });

    document.getElementById('downloadOutputBtn').addEventListener('click', () => {
      const link = document.createElement('a');
      link.download = 'fourier_image.png';
      link.href = reconCanvas.toDataURL('image/png');
      link.click();
    });

    // ============================================
    // QR Card Generation & Sharing
    // ============================================
    
    const shareModal = document.getElementById('shareModal');
    const cardCanvas = document.getElementById('cardCanvas');
    const cardCtx = cardCanvas.getContext('2d');
    let currentShareUrl = '';
    
    // Generate artifact card image
    function generateArtifactCard(artCanvas, coefficients) {
      try {
        const shareUrl = generateShareUrl(coefficients);
        currentShareUrl = shareUrl;
        
        // Card width is fixed
        const cardWidth = 800;
        const margin = 30;
        const artSize = 500;
        
        // Calculate art height and position
        const artHeight = artSize * (artCanvas.height / artCanvas.width);
        const artX = (cardWidth - artSize) / 2;
        const artY = margin + 50;
        
        // Generate QR code (execute first to measure size)
        const tempQrCanvas = document.createElement('canvas');
        const qrResult = generateQRCode(shareUrl, tempQrCanvas, 6);
        
        // URL length warning
        if (shareUrl.length > 2000) {
          console.warn('Share URL is ' + shareUrl.length + ' characters. QR code may be hard to scan. Try reducing K value.');
        }
        
        // QR placement and size calculation
        let qrX, qrY, qrDisplaySize = 0;
        let qrBottom = artY + artHeight + 20; // Default start position if no QR
        
        if (qrResult) {
          // QR size may vary based on data length - adjust placement dynamically
          // Limit max display size to fit on canvas
          const maxQrDisplaySize = 250;
          qrDisplaySize = Math.min(maxQrDisplaySize, qrResult.width);
          
          if (qrDisplaySize > 200) {
            // Large QR at bottom-center
            qrX = (cardWidth - qrDisplaySize) / 2;
            qrY = artY + artHeight + 40;
          } else {
            // Small QR at bottom-right
            qrX = cardWidth - margin - qrDisplaySize;
            qrY = artY + artHeight + 30;
          }
          
          // Margin for text below QR
          qrBottom = qrY + qrDisplaySize + 40;
        } else {
          // Layout for failed QR (reserve space for error message)
          qrBottom = artY + artHeight + 100;
        }
          
        // Rosetta Text content
          const rosettaLines = [
            'Format: IDFT (Real part only) of X, Y, Pen',
            'Formula: v(t) = (1/N) * Œ£ Re(Fk * exp(i*2*œÄ*k*t))',
            '',
            'Data structure: { n: N, k: [indices], d: [coeffs] }',
            '  - N: Original point count',
            '  - k: Selected frequency indices (sorted by amplitude)',
            '  - d: [X coeffs, Y coeffs, Pen coeffs]',
            '       Each: [Re0, Im0, Re1, Im1, ...]',
            '',
            'To reconstruct:',
            '  1. Decode Base64 from URL parameter "d"',
            '  2. Parse JSON to get {n, k, d}',
            '  3. For t ‚àà [0,1), compute:',
            '     x(t) = Œ£ Re(Fxk * exp(i*2*œÄ*fk*N*t)) / N',
            '     y(t) = Œ£ Re(Fyk * exp(i*2*œÄ*fk*N*t)) / N',
            '     pen(t) = clamp(Œ£ Re(Fpenk * ...) / N, 0, 1)',
            '  4. Draw line when pen(t) > 0.5',
            '',
            `K = ${coefficients.k.length}, N = ${coefficients.n}`
          ];
          
          // Calculate Rosetta Text position
          const rosettaY = qrBottom + 30;
          const rosettaLineHeight = 16;
          const rosettaHeight = rosettaLines.length * rosettaLineHeight;
          
          // Calculate required card height
          const cardHeight = rosettaY + rosettaHeight + 60;
          
          // Update canvas size
          cardCanvas.width = cardWidth;
          cardCanvas.height = cardHeight;
          
          // Background
          cardCtx.fillStyle = '#ffffff';
          cardCtx.fillRect(0, 0, cardWidth, cardHeight);
          
          // Title
          cardCtx.fillStyle = '#333333';
          cardCtx.font = 'bold 24px Arial, sans-serif';
          cardCtx.textAlign = 'center';
          cardCtx.fillText('Fourier Art Artifact', cardWidth / 2, margin + 25);
          
          // Border
          cardCtx.strokeStyle = '#333333';
          cardCtx.lineWidth = 2;
          cardCtx.strokeRect(artX - 2, artY - 2, artSize + 4, artHeight + 4);
          
          // Draw art image
          cardCtx.drawImage(artCanvas, artX, artY, artSize, artHeight);
          
          // Draw QR code
          if (qrResult) {
            cardCtx.drawImage(tempQrCanvas, qrX, qrY, qrDisplaySize, qrDisplaySize);
            
            // QR label
            cardCtx.fillStyle = '#666666';
            cardCtx.font = '12px Arial, sans-serif';
            cardCtx.textAlign = 'center';
            cardCtx.fillText('Scan to restore', qrX + qrDisplaySize / 2, qrY + qrDisplaySize + 15);
            
            // QR info
            cardCtx.fillStyle = '#999999';
            cardCtx.font = '10px Arial, sans-serif';
            cardCtx.fillText(`QR Ver.${qrResult.version}`, qrX + qrDisplaySize / 2, qrY + qrDisplaySize + 28);
          } else {
            // Error message for failed QR
            cardCtx.fillStyle = '#cc0000';
            cardCtx.font = 'bold 14px Arial, sans-serif';
            cardCtx.textAlign = 'center';
            cardCtx.fillText('QR Code generation failed (Data too large)', cardWidth / 2, artY + artHeight + 50);
            cardCtx.fillStyle = '#666666';
            cardCtx.font = '12px Arial, sans-serif';
            cardCtx.fillText('URL is valid but too long for QR code.', cardWidth / 2, artY + artHeight + 70);
          }
          
          // Draw Rosetta Text
          const rosettaX = margin;
          
          cardCtx.fillStyle = '#333333';
          cardCtx.font = 'bold 14px monospace';
          cardCtx.textAlign = 'left';
          cardCtx.fillText('=== ROSETTA STONE FOR FUTURE ===', rosettaX, rosettaY);
          
          cardCtx.font = '12px monospace';
          cardCtx.fillStyle = '#555555';
          
          let lineY = rosettaY + 20;
          for (const line of rosettaLines) {
            cardCtx.fillText(line, rosettaX, lineY);
            lineY += rosettaLineHeight;
          }
          
          // Footer
          cardCtx.fillStyle = '#888888';
          cardCtx.font = '10px Arial, sans-serif';
          cardCtx.textAlign = 'center';
          cardCtx.fillText('Generated by FourierPicture | github.com/milky1210/FourierPicture', cardWidth / 2, cardHeight - 15);
          cardCtx.fillText(`Created: ${new Date().toISOString().split('T')[0]}`, cardWidth / 2, cardHeight - 30);
        
        return shareUrl;
      } catch (e) {
        console.error("Error generating artifact card:", e);
        alert("Error generating card: " + e.message);
        return null;
      }
    }
    
    // Create QR Card button
    document.getElementById('shareBtn').addEventListener('click', () => {
      if (!currentCoefficients) {
        alert('Please run the Fourier transform first');
        return;
      }
      
      generateArtifactCard(reconCanvas, currentCoefficients);
      shareModal.style.display = 'flex';
    });
    
    // Download card
    document.getElementById('downloadCardBtn').addEventListener('click', () => {
      const link = document.createElement('a');
      link.download = 'fourier_artifact_card.png';
      link.href = cardCanvas.toDataURL('image/png');
      link.click();
    });
    
    // Copy URL
    document.getElementById('copyUrlBtn').addEventListener('click', async () => {
      if (currentShareUrl) {
        try {
          await navigator.clipboard.writeText(currentShareUrl);
          alert('URL copied to clipboard');
        } catch (e) {
          // Fallback
          const textArea = document.createElement('textarea');
          textArea.value = currentShareUrl;
          document.body.appendChild(textArea);
          textArea.select();
          document.execCommand('copy');
          document.body.removeChild(textArea);
          alert('URL copied to clipboard');
        }
      }
    });
    
    // Close modal
    document.getElementById('closeModalBtn').addEventListener('click', () => {
      shareModal.style.display = 'none';
    });
    
    // Close modal on outside click
    shareModal.addEventListener('click', (e) => {
      if (e.target === shareModal) {
        shareModal.style.display = 'none';
      }
    });
    
    // ============================================
    // URL Parameter Restoration (Viewer Mode)
    // ============================================
    
    // Generate animation frames from shared data
    function generateAnimationFramesFromCoefficients(data, numFrames) {
      const K = data.k.length;
      const is3d = data.d.length === 3;
      
      if (K === 0) return [];
      if (K < 2) {
        const points = reconstructFromCoefficients(data);
        return [{ K: K, points: points, isFinal: true }];
      }
      
      const kMin = 2;
      const kMax = K;
      
      const kValuesSet = new Set();
      for (let i = 0; i < numFrames; i++) {
        let k;
        if (numFrames === 1) {
          k = kMax;
        } else {
          const t = i / (numFrames - 1);
          const tAdjusted = Math.pow(t, 0.6);
          const logK = Math.log(kMin) + (Math.log(kMax) - Math.log(kMin)) * tAdjusted;
          k = Math.round(Math.exp(logK));
        }
        k = Math.max(kMin, Math.min(k, kMax));
        kValuesSet.add(k);
      }
      
      const kValues = Array.from(kValuesSet).sort((a, b) => a - b);
      
      const frames = [];
      for (const k of kValues) {
        // Use only k coefficients
        const partialData = {
          f: data.f,
          n: data.n,
          k: data.k.slice(0, k),
          d: data.d.map(arr => arr.slice(0, k * 2))
        };
        const reconstructed = reconstructFromCoefficients(partialData);
        frames.push({
          K: k,
          points: reconstructed,
          isFinal: false
        });
      }
      
      // Final frame (all coefficients)
      const finalPoints = reconstructFromCoefficients(data);
      frames.push({
        K: K,
        points: finalPoints,
        isFinal: true
      });
      
      return frames;
    }
    
    // Initialize viewer mode
    function initViewerMode(data) {
      const is3d = data.d.length === 3;
      
      // Hide left panel, expand right panel
      document.querySelector('.left-panel').style.display = 'none';
      document.querySelector('.right-panel').style.flex = '1';
      document.querySelector('.right-panel .panel-title').textContent = 'Shared Fourier Art';
      
      // Change button visibility
      document.getElementById('shareBtn').style.display = 'none';
      
      // Add new buttons
      const buttonGroup = document.querySelector('.right-panel .button-group');
      
      // Animation play button
      const playBtn = document.createElement('button');
      playBtn.id = 'viewerPlayBtn';
      playBtn.className = 'animation';
      playBtn.textContent = 'Play Animation';
      buttonGroup.appendChild(playBtn);
      
      // Video download button
      const videoBtn = document.createElement('button');
      videoBtn.id = 'viewerVideoBtn';
      videoBtn.className = 'animation';
      videoBtn.textContent = 'Download GIF';
      videoBtn.disabled = true;
      buttonGroup.appendChild(videoBtn);
      
      // New creation link
      const newBtn = document.createElement('button');
      newBtn.className = 'secondary';
      newBtn.textContent = 'Create New';
      newBtn.addEventListener('click', () => {
        window.location.href = window.location.pathname;
      });
      buttonGroup.appendChild(newBtn);
      
      // Initial drawing
      const points = reconstructFromCoefficients(data);
      drawPoints(rctx, reconCanvas, points);
      updateStatus(`Restored (K=${data.k.length}, N=${data.n})`);
      
      // Save coefficient data (viewer mode - not used for sharing)
      currentCoefficients = data;
      
      // Animation play
      playBtn.addEventListener('click', () => {
        if (animationId) {
          cancelAnimationFrame(animationId);
          clearTimeout(animationId);
          animationId = null;
        }
        
        animationFrames = generateAnimationFramesFromCoefficients(data, 30);
        
        if (animationFrames.length === 0) {
          updateStatus('No animation data');
          return;
        }
        
        currentFrameIndex = 0;
        isPlaying = true;
        videoBtn.disabled = false;
        
        showProgress(true);
        updateStatus(`Playing animation (${animationFrames.length} frames)`);
        playAnimation();
      });
      
      // Video download
      videoBtn.addEventListener('click', async () => {
        if (animationFrames.length === 0) {
          // Generate if not yet generated
          animationFrames = generateAnimationFramesFromCoefficients(data, 30);
        }
        
        if (animationFrames.length === 0) {
          alert('No animation data');
          return;
        }
        
        isPlaying = false;
        if (animationId) {
          cancelAnimationFrame(animationId);
          clearTimeout(animationId);
          animationId = null;
        }
        
        updateStatus('Generating GIF...');
        showProgress(true);
        setProgress(0);
        
        try {
          const gif = new GIF({
          workers: 0,
          quality: 10,
          width: reconCanvas.width,
          height: reconCanvas.height
          // Add each frame
          for (let i = 0; i < animationFrames.length; i++) {
            const frame = animationFrames[i];
            drawPoints(rctx, reconCanvas, frame.points);
            
            const delay = frame.isFinal ? 3000 : 100;
            gif.addFrame(reconCanvas, {copy: true, delay: delay});
            
            setProgress(((i + 1) / animationFrames.length) * 50);
          }
          
          gif.on('finished', (blob) => {
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'fourier_animation.gif';
            link.click();
            URL.revokeObjectURL(url);
            
            updateStatus('GIF download complete');
            showProgress(false);
            
            // Show final frame
            const finalPoints = reconstructFromCoefficients(data);
            drawPoints(rctx, reconCanvas, finalPoints);
          });
          
          gif.on('progress', (progress) => {
            setProgress(50 + progress * 50);
          });
          
          gif.render();
          
        } catch (error) {
          console.error("Error:", error);
          alert("Error generating GIF: " + error.message);
          updateStatus('GIF generation failed');
          showProgress(false);
        }
      });
    }
    
    // ============================================
    // Initialization
    // ============================================
    
    // Check URL params on page load
    window.addEventListener('load', () => {
      const sharedData = loadFromUrlParams();
      
      if (sharedData) {
        // Start in viewer mode
        initViewerMode(sharedData);
      } else {
        // Normal mode - share button enabled after transform
        document.getElementById('shareBtn').disabled = true;
      }
    });

    // ============================================
    // Menu Functions
    // ============================================
    
    const menuBtn = document.getElementById('menuBtn');
    const menuPanel = document.getElementById('menuPanel');
    const menuOverlay = document.getElementById('menuOverlay');
    const menuCloseBtn = document.getElementById('menuCloseBtn');
    
    function openMenu() {
      menuPanel.classList.add('open');
      menuOverlay.classList.add('open');
      // Sync menu parameters with current values
      document.getElementById('menuKValue').value = document.getElementById('kValue').value;
      document.getElementById('menuNumFrames').value = document.getElementById('numFrames').value;
      updateSavedWorksList();
    }
    
    function closeMenu() {
      menuPanel.classList.remove('open');
      menuOverlay.classList.remove('open');
    }
    
    menuBtn.addEventListener('click', openMenu);
    menuCloseBtn.addEventListener('click', closeMenu);
    menuOverlay.addEventListener('click', closeMenu);
    
    // Parameter sync
    document.getElementById('menuKValue').addEventListener('change', (e) => {
      document.getElementById('kValue').value = e.target.value;
    });
    
    document.getElementById('menuNumFrames').addEventListener('change', (e) => {
      document.getElementById('numFrames').value = e.target.value;
    });
    
    // Sampling interval display update
    const svgSampleInterval = document.getElementById('svgSampleInterval');
    const svgSampleIntervalValue = document.getElementById('svgSampleIntervalValue');
    svgSampleInterval.addEventListener('input', () => {
      svgSampleIntervalValue.textContent = svgSampleInterval.value;
    });
    
    // Pen threshold display update
    const menuPenThreshold = document.getElementById('menuPenThreshold');
    const menuPenThresholdValue = document.getElementById('menuPenThresholdValue');
    menuPenThreshold.addEventListener('input', () => {
      menuPenThresholdValue.textContent = (menuPenThreshold.value / 100).toFixed(2);
    });

    // ============================================
    // SVG Import Functions
    // ============================================
    
    // SVG import constants
    const DEFAULT_SAMPLE_INTERVAL = 5;  // Default sampling interval (px)
    const ENDPOINT_TOLERANCE = 0.1;     // Endpoint comparison tolerance (px)
    const CANVAS_MARGIN = 40;           // Canvas margin (px)
    
    /**
     * Generate point cloud data from SVG file
     * @param {File} file - SVG file
     * @returns {Promise<{x: number[], y: number[], pen: number[]}>}
     */
    async function importSVG(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        
        reader.onload = (e) => {
          try {
            const svgText = e.target.result;
            const result = parseSVGToPoints(svgText);
            resolve(result);
          } catch (err) {
            reject(err);
          }
        };
        
        reader.onerror = () => reject(new Error('Failed to read file'));
        reader.readAsText(file);
      });
    }
    
    /**
     * Parse SVG string and convert to point cloud data
     * @param {string} svgText - SVG string
     * @returns {{x: number[], y: number[], pen: number[]}}
     */
    function parseSVGToPoints(svgText) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(svgText, 'image/svg+xml');
      
      // Check for parse errors
      const parseError = doc.querySelector('parsererror');
      if (parseError) {
        throw new Error('Failed to parse SVG: ' + parseError.textContent);
      }
      
      // Temporarily add SVG to DOM to enable getTotalLength/getPointAtLength
      const svgElement = doc.documentElement;
      const tempContainer = document.createElement('div');
      tempContainer.style.cssText = 'position:absolute;visibility:hidden;width:0;height:0;overflow:hidden;';
      document.body.appendChild(tempContainer);
      
      // Clone and append SVG
      const svgClone = svgElement.cloneNode(true);
      tempContainer.appendChild(svgClone);
      
      // Get sampling interval
      const sampleInterval = parseInt(svgSampleInterval.value) || DEFAULT_SAMPLE_INTERVAL;
      
      // Get all <path> elements
      const paths = svgClone.querySelectorAll('path');
      
      const x = [];
      const y = [];
      const pen = [];
      
      paths.forEach((path, pathIndex) => {
        try {
          const totalLength = path.getTotalLength();
          
          if (totalLength === 0) return;
          
          // Sample points along path (pen=1 for drawing)
          for (let length = 0; length <= totalLength; length += sampleInterval) {
            const point = path.getPointAtLength(length);
            x.push(point.x);
            y.push(point.y);
            pen.push(1);
          }
          
          // Ensure last point is included
          const endPoint = path.getPointAtLength(totalLength);
          if (x.length === 0 || 
              Math.abs(x[x.length - 1] - endPoint.x) > ENDPOINT_TOLERANCE || 
              Math.abs(y[y.length - 1] - endPoint.y) > ENDPOINT_TOLERANCE) {
            x.push(endPoint.x);
            y.push(endPoint.y);
            pen.push(1);
          }
          
          // After path ends, if there are more paths, add pen=0 to indicate movement
          // For all paths except the last, add end point with pen=0 to mark stroke end
          if (pathIndex < paths.length - 1) {
            // Add current path's end point with pen=0 (stroke end marker)
            x.push(endPoint.x);
            y.push(endPoint.y);
            pen.push(0);
          }
        } catch (pathErr) {
          console.warn('Error processing path:', pathErr);
        }
      });
      
      // Remove temp container
      document.body.removeChild(tempContainer);
      
      if (x.length === 0) {
        throw new Error('No valid paths found in SVG. Please ensure the file contains <path> elements.');
      }
      
      // Normalize coordinates
      return normalizePoints(x, y, pen);
    }
    
    /**
     * Normalize point cloud data (centering and scaling)
     * @param {number[]} x - X coordinate array
     * @param {number[]} y - Y coordinate array
     * @param {number[]} pen - Pen state array
     * @returns {{x: number[], y: number[], pen: number[]}}
     */
    function normalizePoints(x, y, pen) {
      if (x.length === 0) {
        return { x: [], y: [], pen: [] };
      }
      
      // Calculate bounding box
      let minX = Infinity, maxX = -Infinity;
      let minY = Infinity, maxY = -Infinity;
      
      for (let i = 0; i < x.length; i++) {
        minX = Math.min(minX, x[i]);
        maxX = Math.max(maxX, x[i]);
        minY = Math.min(minY, y[i]);
        maxY = Math.max(maxY, y[i]);
      }
      
      // Calculate center
      const centerX = (minX + maxX) / 2;
      const centerY = (minY + maxY) / 2;
      
      // Calculate size
      const width = maxX - minX;
      const height = maxY - minY;
      const maxDimension = Math.max(width, height);
      
      // Scale to fit canvas (600x400) with margin
      const canvasWidth = canvas.width;
      const canvasHeight = canvas.height;
      
      const scaleX = (canvasWidth - CANVAS_MARGIN * 2) / width;
      const scaleY = (canvasHeight - CANVAS_MARGIN * 2) / height;
      const scale = Math.min(scaleX, scaleY);
      
      // Calculate normalized coordinates
      const normalizedX = [];
      const normalizedY = [];
      
      for (let i = 0; i < x.length; i++) {
        // Center and scale
        const nx = (x[i] - centerX) * scale + canvasWidth / 2;
        const ny = (y[i] - centerY) * scale + canvasHeight / 2;
        normalizedX.push(nx);
        normalizedY.push(ny);
      }
      
      return {
        x: normalizedX,
        y: normalizedY,
        pen: pen
      };
    }
    
    /**
     * Apply imported point cloud data to stroke data
     * @param {{x: number[], y: number[], pen: number[]}} data - Point cloud data
     */
    function applyImportedPoints(data) {
      // Clear existing data
      strokes = [];
      currentStroke = [];
      
      // Split into strokes based on pen state
      let currentStrokeData = [];
      
      for (let i = 0; i < data.x.length; i++) {
        if (data.pen[i] === 1) {
          currentStrokeData.push([data.x[i], data.y[i]]);
        } else {
          // pen=0: end current stroke and start new one
          if (currentStrokeData.length > 0) {
            strokes.push(currentStrokeData);
            currentStrokeData = [];
          }
        }
      }
      
      // Add last stroke
      if (currentStrokeData.length > 0) {
        strokes.push(currentStrokeData);
      }
      
      // Enable multi-stroke mode
      document.getElementById('multiStrokeMode').checked = true;
      multiStrokeMode = true;
      document.getElementById('modeInfo').textContent = 'Multi-stroke Mode: Draw multiple lines. Gaps between strokes appear faded.';
      
      // Redraw canvas
      redrawInputCanvas();
      
      updateStatus(`Imported SVG (${strokes.length} strokes, ${data.x.length} points)`);
    }
    
    // SVG file selection event
    document.getElementById('svgFileInput').addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      if (!file.name.toLowerCase().endsWith('.svg')) {
        alert('Please select an SVG file');
        return;
      }
      
      updateStatus('Importing SVG...');
      
      try {
        const pointsData = await importSVG(file);
        applyImportedPoints(pointsData);
        closeMenu();
      } catch (err) {
        console.error('SVG import error:', err);
        alert('Failed to import SVG: ' + err.message);
        updateStatus('SVG import failed');
      }
      
      // Reset file input
      e.target.value = '';
    });

    // ============================================
    // Save/Load Work Functions
    // ============================================
    
    const STORAGE_KEY = 'fourier_picture_works';
    
    /**
     * Get saved works list
     * @returns {Array<{name: string, data: object, timestamp: number}>}
     */
    function getSavedWorks() {
      try {
        const data = localStorage.getItem(STORAGE_KEY);
        return data ? JSON.parse(data) : [];
      } catch (e) {
        console.error('Failed to load saved data:', e);
        return [];
      }
    }
    
    /**
     * Save works list
     * @param {Array} works - Works list
     */
    function setSavedWorks(works) {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(works));
      } catch (e) {
        console.error('Failed to save:', e);
        alert('Failed to save. Storage may be full.');
      }
    }
    
    /**
     * Save current work
     * @param {string} name - Work name
     */
    function saveCurrentWork(name) {
      if (!name || name.trim() === '') {
        alert('Please enter a work name');
        return false;
      }
      
      const workData = {
        strokes: strokes,
        multiStrokeMode: multiStrokeMode,
        kValue: parseInt(document.getElementById('kValue').value),
        numFrames: parseInt(document.getElementById('numFrames').value)
      };
      
      const works = getSavedWorks();
      
      // Check for duplicate name
      const existingIndex = works.findIndex(w => w.name === name.trim());
      if (existingIndex !== -1) {
        if (!confirm(`"${name}" already exists. Overwrite?`)) {
          return false;
        }
        works[existingIndex] = {
          name: name.trim(),
          data: workData,
          timestamp: Date.now()
        };
      } else {
        works.push({
          name: name.trim(),
          data: workData,
          timestamp: Date.now()
        });
      }
      
      setSavedWorks(works);
      updateSavedWorksList();
      return true;
    }
    
    /**
     * Load work
     * @param {number} index - Work index
     */
    function loadWork(index) {
      const works = getSavedWorks();
      if (index < 0 || index >= works.length) {
        alert('Work not found');
        return;
      }
      
      const work = works[index];
      
      // Restore data
      strokes = work.data.strokes || [];
      currentStroke = [];
      multiStrokeMode = work.data.multiStrokeMode !== false;
      
      document.getElementById('multiStrokeMode').checked = multiStrokeMode;
      document.getElementById('modeInfo').textContent = multiStrokeMode 
        ? 'Multi-stroke Mode: Draw multiple lines. Gaps between strokes appear faded.'
        : 'Single-stroke Mode: Canvas resets on each new stroke';
      
      if (work.data.kValue) {
        document.getElementById('kValue').value = work.data.kValue;
        document.getElementById('menuKValue').value = work.data.kValue;
      }
      
      if (work.data.numFrames) {
        document.getElementById('numFrames').value = work.data.numFrames;
        document.getElementById('menuNumFrames').value = work.data.numFrames;
      }
      
      // Redraw canvas
      redrawInputCanvas();
      initCanvas(rctx, reconCanvas);
      
      updateStatus(`Loaded "${work.name}"`);
      closeMenu();
    }
    
    /**
     * Delete work
     * @param {number} index - Work index
     */
    function deleteWork(index) {
      const works = getSavedWorks();
      if (index < 0 || index >= works.length) {
        return;
      }
      
      const work = works[index];
      if (!confirm(`Delete "${work.name}"?`)) {
        return;
      }
      
      works.splice(index, 1);
      setSavedWorks(works);
      updateSavedWorksList();
    }
    
    /**
     * Update saved works list UI
     */
    function updateSavedWorksList() {
      const listContainer = document.getElementById('savedWorksList');
      const works = getSavedWorks();
      
      if (works.length === 0) {
        listContainer.innerHTML = '<div class="no-saved-works">No saved works</div>';
        return;
      }
      
      // Sort by date (newest first)
      works.sort((a, b) => b.timestamp - a.timestamp);
      
      let html = '';
      works.forEach((work, index) => {
        const date = new Date(work.timestamp).toLocaleDateString('en-US');
        // XSS protection: escape work.name
        const escapedName = work.name.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        html += `
          <div class="saved-work-item">
            <span title="${escapedName} (${date})">${escapedName}</span>
            <button class="load-btn" data-action="load" data-index="${index}">Load</button>
            <button class="delete-btn" data-action="delete" data-index="${index}">Delete</button>
          </div>
        `;
      });
      
      listContainer.innerHTML = html;
    }
    
    // Event delegation for saved works list button handling
    document.getElementById('savedWorksList').addEventListener('click', (e) => {
      const target = e.target;
      if (target.tagName !== 'BUTTON') return;
      
      const action = target.dataset.action;
      const index = parseInt(target.dataset.index, 10);
      
      if (isNaN(index)) return;
      
      if (action === 'load') {
        loadWork(index);
      } else if (action === 'delete') {
        deleteWork(index);
      }
    });
    
    // Save button event
    document.getElementById('saveWorkBtn').addEventListener('click', () => {
      const nameInput = document.getElementById('saveWorkName');
      const name = nameInput.value;
      
      if (strokes.length === 0) {
        alert('No work to save. Please draw something first.');
        return;
      }
      
      if (saveCurrentWork(name)) {
        nameInput.value = '';
        alert('Work saved');
      }
    });
  </script>
</body>
</html>
