<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Fourier Transform Doodle Art</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="alternate" hreflang="ja" href="index.html">
  <link rel="alternate" hreflang="en" href="en.html">
  <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: 'Arial', sans-serif;
      background-color: #f5f5f5;
      padding: 20px;
    }
    h1 {
      text-align: center;
      color: #333;
      margin-bottom: 20px;
    }
    .container {
      display: flex;
      gap: 20px;
      max-width: 1400px;
      margin: 0 auto;
      background-color: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    @media (max-width: 900px) {
      .container {
        flex-direction: column;
      }
    }
    .left-panel, .right-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
    }
    .panel-title {
      font-size: 18px;
      font-weight: bold;
      margin-bottom: 10px;
      color: #555;
    }
    canvas {
      border: 2px solid #333;
      border-radius: 5px;
      cursor: crosshair;
      background-color: white;
      max-width: 100%;
      height: auto;
    }
    .controls {
      margin-top: 15px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .control-group {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    label {
      font-weight: bold;
      color: #555;
    }
    input[type="number"] {
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
      width: 100px;
    }
    input[type="checkbox"] {
      width: 18px;
      height: 18px;
    }
    button {
      padding: 10px 20px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      font-size: 14px;
      cursor: pointer;
      transition: background-color 0.3s;
    }
    button:hover {
      background-color: #45a049;
    }
    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    button.secondary {
      background-color: #2196F3;
    }
    button.secondary:hover {
      background-color: #0b7dda;
    }
    button.clear {
      background-color: #f44336;
    }
    button.clear:hover {
      background-color: #da190b;
    }
    button.animation {
      background-color: #9C27B0;
    }
    button.animation:hover {
      background-color: #7B1FA2;
    }
    button.share {
      background-color: #FF9800;
    }
    button.share:hover {
      background-color: #F57C00;
    }
    .button-group {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.7);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    .modal-content {
      background-color: white;
      padding: 20px;
      border-radius: 10px;
      max-width: 90%;
      max-height: 90%;
      overflow: auto;
      text-align: center;
    }
    .modal-content h2 {
      margin-bottom: 15px;
      color: #333;
    }
    .modal-content canvas {
      border: 1px solid #ccc;
      cursor: default;
    }
    .modal-buttons {
      margin-top: 15px;
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
    }
    .modal-close {
      background-color: #666;
    }
    .modal-close:hover {
      background-color: #555;
    }
    .status {
      font-size: 14px;
      color: #666;
      padding: 10px;
      background-color: #f0f0f0;
      border-radius: 4px;
      min-height: 40px;
    }
    .progress-container {
      width: 100%;
      height: 20px;
      background-color: #e0e0e0;
      border-radius: 10px;
      overflow: hidden;
      margin-top: 5px;
    }
    .progress-bar {
      height: 100%;
      background-color: #9C27B0;
      width: 0%;
      transition: width 0.1s;
    }
    .mode-info {
      font-size: 12px;
      color: #888;
      margin-top: 5px;
    }
    footer {
      text-align: center;
      margin-top: 20px;
      color: #888;
      font-size: 12px;
    }
    footer a {
      color: #2196F3;
      text-decoration: none;
    }
    footer a:hover {
      text-decoration: underline;
    }
    .lang-switch {
      text-align: right;
      margin-bottom: 10px;
    }
    .lang-switch a {
      color: #2196F3;
      text-decoration: none;
    }
  </style>
</head>
<body>
  <div class="lang-switch">
    <a href="index.html">ðŸ‡¯ðŸ‡µ æ—¥æœ¬èªž</a>
  </div>
  
  <h1>Fourier Transform Doodle Art</h1>
  
  <div class="container">
    <!-- Left Panel: Input -->
    <div class="left-panel">
      <div class="panel-title">Drawing Canvas</div>
      <canvas id="drawCanvas" width="600" height="400"></canvas>
      
      <div class="controls">
        <div class="control-group">
          <label for="multiStrokeMode">
            <input type="checkbox" id="multiStrokeMode" checked> Multi-stroke Mode
          </label>
        </div>
        <div class="mode-info" id="modeInfo">Multi-stroke Mode: Draw multiple lines. Gaps between strokes appear faded.</div>
        
        <div class="control-group">
          <label for="kValue">Fourier Terms K:</label>
          <input type="number" id="kValue" value="10" min="1" max="1000">
        </div>
        
        <div class="button-group">
          <button id="processBtn">Transform</button>
          <button id="clearBtn" class="clear">Clear</button>
          <button id="downloadInputBtn" class="secondary">Download Input</button>
        </div>
        
        <div class="control-group">
          <label for="numFrames">Animation Frames:</label>
          <input type="number" id="numFrames" value="30" min="5" max="100">
        </div>
        
        <div class="button-group">
          <button id="animationBtn" class="animation">Generate Animation</button>
          <button id="downloadVideoBtn" class="animation" disabled>Download Video</button>
        </div>
      </div>
    </div>
    
    <!-- Right Panel: Output -->
    <div class="right-panel">
      <div class="panel-title">Generated Image</div>
      <canvas id="reconCanvas" width="600" height="400"></canvas>
      
      <div class="controls">
        <div class="status" id="statusText">Draw something and click Transform</div>
        <div class="progress-container" id="progressContainer" style="display: none;">
          <div class="progress-bar" id="progressBar"></div>
        </div>
        <div class="button-group">
          <button id="downloadOutputBtn" class="secondary">Download Output</button>
          <button id="shareBtn" class="share" disabled>Create QR Card</button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- QR Card Modal -->
  <div id="shareModal" class="modal-overlay">
    <div class="modal-content">
      <h2>ðŸ“œ Artifact (Permanent Storage Card)</h2>
      <canvas id="cardCanvas" width="800" height="900"></canvas>
      <div class="modal-buttons">
        <button id="downloadCardBtn" class="secondary">Download Card Image</button>
        <button id="copyUrlBtn" class="secondary">Copy URL</button>
        <button id="closeModalBtn" class="modal-close">Close</button>
      </div>
    </div>
  </div>
  
  <footer>
    <p>Created by <a href="https://github.com/milky1210" target="_blank">milky1210</a> | <a href="https://github.com/milky1210/FourierPicture" target="_blank">GitHub</a></p>
    <p>First Published: 2025-11-27 (See <a href="https://github.com/milky1210/FourierPicture/commits/main" target="_blank">git history</a> for precise timestamp)</p>
  </footer>
  
  <script>
    // ============================================
    // FFT Implementation (JavaScript)
    // ============================================
    
    class Complex {
      constructor(re, im) {
        this.re = re;
        this.im = im;
      }
      
      add(other) {
        return new Complex(this.re + other.re, this.im + other.im);
      }
      
      sub(other) {
        return new Complex(this.re - other.re, this.im - other.im);
      }
      
      mul(other) {
        return new Complex(
          this.re * other.re - this.im * other.im,
          this.re * other.im + this.im * other.re
        );
      }
      
      scale(s) {
        return new Complex(this.re * s, this.im * s);
      }
      
      abs() {
        return Math.sqrt(this.re * this.re + this.im * this.im);
      }
    }
    
    function dft(input) {
      const N = input.length;
      const output = [];
      
      for (let k = 0; k < N; k++) {
        let sum = new Complex(0, 0);
        for (let n = 0; n < N; n++) {
          const angle = -2 * Math.PI * k * n / N;
          const exp = new Complex(Math.cos(angle), Math.sin(angle));
          sum = sum.add(input[n].mul(exp));
        }
        output.push(sum);
      }
      
      return output;
    }
    
    function fftfreq(N) {
      const freqs = [];
      for (let i = 0; i < N; i++) {
        if (i < Math.floor((N + 1) / 2)) {
          freqs.push(i / N);
        } else {
          freqs.push((i - N) / N);
        }
      }
      return freqs;
    }
    
    function reconstructFourier2d(points, K) {
      const N = points.length;
      if (N === 0) return [];
      
      const z = points.map(p => new Complex(p[0], p[1]));
      const F = dft(z);
      const freqs = fftfreq(N);
      
      const amplitudes = F.map(c => c.abs());
      const indices = Array.from({ length: N }, (_, i) => i);
      indices.sort((a, b) => amplitudes[b] - amplitudes[a]);
      
      const actualK = Math.min(K, N);
      const selectedIndices = indices.slice(0, actualK);
      
      const numOutputPoints = Math.max(N, 200);
      const result = [];
      
      for (let i = 0; i < numOutputPoints; i++) {
        const t = i / numOutputPoints;
        let sum = new Complex(0, 0);
        
        for (const k of selectedIndices) {
          const freq = freqs[k] * N;
          const angle = 2 * Math.PI * freq * t;
          const exp = new Complex(Math.cos(angle), Math.sin(angle));
          sum = sum.add(F[k].scale(1 / N).mul(exp));
        }
        
        result.push([sum.re, sum.im]);
      }
      
      return result;
    }
    
    function reconstructFourier3d(points, K) {
      const N = points.length;
      if (N === 0) return [];
      
      const x = points.map(p => new Complex(p[0], 0));
      const y = points.map(p => new Complex(p[1], 0));
      const pen = points.map(p => new Complex(p[2], 0));
      
      const Fx = dft(x);
      const Fy = dft(y);
      const Fpen = dft(pen);
      const freqs = fftfreq(N);
      
      const amplitudes = [];
      for (let i = 0; i < N; i++) {
        amplitudes.push(Fx[i].abs() + Fy[i].abs() + Fpen[i].abs());
      }
      const indices = Array.from({ length: N }, (_, i) => i);
      indices.sort((a, b) => amplitudes[b] - amplitudes[a]);
      
      const actualK = Math.min(K, N);
      const selectedIndices = indices.slice(0, actualK);
      
      const numOutputPoints = Math.max(N, 200);
      const result = [];
      
      for (let i = 0; i < numOutputPoints; i++) {
        const t = i / numOutputPoints;
        let sumX = new Complex(0, 0);
        let sumY = new Complex(0, 0);
        let sumPen = new Complex(0, 0);
        
        for (const k of selectedIndices) {
          const freq = freqs[k] * N;
          const angle = 2 * Math.PI * freq * t;
          const exp = new Complex(Math.cos(angle), Math.sin(angle));
          sumX = sumX.add(Fx[k].scale(1 / N).mul(exp));
          sumY = sumY.add(Fy[k].scale(1 / N).mul(exp));
          sumPen = sumPen.add(Fpen[k].scale(1 / N).mul(exp));
        }
        
        const penVal = Math.max(0, Math.min(1, sumPen.re));
        result.push([sumX.re, sumY.re, penVal]);
      }
      
      return result;
    }
    
    function generateAnimationFrames(points, numFrames, is3d) {
      const N = points.length;
      if (N === 0) return [];
      if (N < 2) return [{ K: N, points: points, isFinal: true }];
      
      const reconstructFn = is3d ? reconstructFourier3d : reconstructFourier2d;
      
      const kMin = 2;
      const kMax = N;
      
      const kValuesSet = new Set();
      for (let i = 0; i < numFrames; i++) {
        let k;
        if (numFrames === 1) {
          k = kMax;
        } else {
          const t = i / (numFrames - 1);
          const tAdjusted = Math.pow(t, 0.6);
          const logK = Math.log(kMin) + (Math.log(kMax) - Math.log(kMin)) * tAdjusted;
          k = Math.round(Math.exp(logK));
        }
        k = Math.max(kMin, Math.min(k, kMax));
        kValuesSet.add(k);
      }
      
      const kValues = Array.from(kValuesSet).sort((a, b) => a - b);
      
      const frames = [];
      for (const k of kValues) {
        const reconstructed = reconstructFn(points, k);
        frames.push({
          K: k,
          points: reconstructed,
          isFinal: false
        });
      }
      
      const finalPoints = reconstructFn(points, N);
      frames.push({
        K: N,
        points: finalPoints,
        isFinal: true
      });
      
      return frames;
    }

    // ============================================
    // Data Export/Import Functions
    // QR code generation uses qrcode-generator CDN library
    // ============================================
    
    // Round number to specified decimals
    function roundNumber(num, decimals) {
      const factor = Math.pow(10, decimals);
      return Math.round(num * factor) / factor;
    }
    
    // Get Fourier coefficients (limited to K for sharing)
    function getFourierCoefficients(points, K, is3d) {
      const N = points.length;
      if (N === 0) return null;
      
      const actualK = Math.min(K, N);
      
      if (is3d) {
        const x = points.map(p => new Complex(p[0], 0));
        const y = points.map(p => new Complex(p[1], 0));
        const pen = points.map(p => new Complex(p[2], 0));
        
        const Fx = dft(x);
        const Fy = dft(y);
        const Fpen = dft(pen);
        
        // Sort by amplitude
        const amplitudes = [];
        for (let i = 0; i < N; i++) {
          amplitudes.push(Fx[i].abs() + Fy[i].abs() + Fpen[i].abs());
        }
        const indices = Array.from({ length: N }, (_, i) => i);
        indices.sort((a, b) => amplitudes[b] - amplitudes[a]);
        const selectedIndices = indices.slice(0, actualK);
        
        // Coefficient data (Re, Im alternating)
        const coeffX = [];
        const coeffY = [];
        const coeffPen = [];
        
        for (const k of selectedIndices) {
          coeffX.push(roundNumber(Fx[k].re, 3), roundNumber(Fx[k].im, 3));
          coeffY.push(roundNumber(Fy[k].re, 3), roundNumber(Fy[k].im, 3));
          coeffPen.push(roundNumber(Fpen[k].re, 3), roundNumber(Fpen[k].im, 3));
        }
        
        return {
          f: "v(t)=Sum(Re(Fk*exp(i*2*pi*k*t)))",
          n: N,
          k: selectedIndices.map(i => i),
          d: [coeffX, coeffY, coeffPen]
        };
      } else {
        const z = points.map(p => new Complex(p[0], p[1]));
        const F = dft(z);
        
        const amplitudes = F.map(c => c.abs());
        const indices = Array.from({ length: N }, (_, i) => i);
        indices.sort((a, b) => amplitudes[b] - amplitudes[a]);
        const selectedIndices = indices.slice(0, actualK);
        
        const coeffZ = [];
        for (const k of selectedIndices) {
          coeffZ.push(roundNumber(F[k].re, 3), roundNumber(F[k].im, 3));
        }
        
        return {
          f: "z(t)=Sum(Fk*exp(i*2*pi*k*t))",
          n: N,
          k: selectedIndices.map(i => i),
          d: [coeffZ]
        };
      }
    }
    
    // Reconstruct from coefficients
    function reconstructFromCoefficients(data) {
      const N = data.n;
      const K = data.k;
      const is3d = data.d.length === 3;
      const freqs = fftfreq(N);
      
      const numOutputPoints = Math.max(N, 200);
      const result = [];
      
      if (is3d) {
        const coeffX = data.d[0];
        const coeffY = data.d[1];
        const coeffPen = data.d[2];
        
        for (let i = 0; i < numOutputPoints; i++) {
          const t = i / numOutputPoints;
          let sumX = new Complex(0, 0);
          let sumY = new Complex(0, 0);
          let sumPen = new Complex(0, 0);
          
          for (let j = 0; j < K.length; j++) {
            const k = K[j];
            const freq = freqs[k] * N;
            const angle = 2 * Math.PI * freq * t;
            const exp = new Complex(Math.cos(angle), Math.sin(angle));
            
            const Fxk = new Complex(coeffX[j * 2], coeffX[j * 2 + 1]);
            const Fyk = new Complex(coeffY[j * 2], coeffY[j * 2 + 1]);
            const Fpenk = new Complex(coeffPen[j * 2], coeffPen[j * 2 + 1]);
            
            sumX = sumX.add(Fxk.scale(1 / N).mul(exp));
            sumY = sumY.add(Fyk.scale(1 / N).mul(exp));
            sumPen = sumPen.add(Fpenk.scale(1 / N).mul(exp));
          }
          
          const penVal = Math.max(0, Math.min(1, sumPen.re));
          result.push([sumX.re, sumY.re, penVal]);
        }
      } else {
        const coeffZ = data.d[0];
        
        for (let i = 0; i < numOutputPoints; i++) {
          const t = i / numOutputPoints;
          let sum = new Complex(0, 0);
          
          for (let j = 0; j < K.length; j++) {
            const k = K[j];
            const freq = freqs[k] * N;
            const angle = 2 * Math.PI * freq * t;
            const exp = new Complex(Math.cos(angle), Math.sin(angle));
            
            const Fk = new Complex(coeffZ[j * 2], coeffZ[j * 2 + 1]);
            sum = sum.add(Fk.scale(1 / N).mul(exp));
          }
          
          result.push([sum.re, sum.im]);
        }
      }
      
      return result;
    }
    
    // Encode data to Base64
    function encodeDataToBase64(data) {
      const jsonStr = JSON.stringify(data);
      // UTF-8 compatible Base64 encoding
      const utf8Bytes = new TextEncoder().encode(jsonStr);
      const binaryStr = Array.from(utf8Bytes, byte => String.fromCharCode(byte)).join('');
      return btoa(binaryStr);
    }
    
    // Decode data from Base64
    function decodeDataFromBase64(base64Str) {
      try {
        const binaryStr = atob(base64Str);
        const bytes = new Uint8Array(binaryStr.length);
        for (let i = 0; i < binaryStr.length; i++) {
          bytes[i] = binaryStr.charCodeAt(i);
        }
        const jsonStr = new TextDecoder().decode(bytes);
        return JSON.parse(jsonStr);
      } catch (e) {
        console.error('Failed to decode data:', e);
        return null;
      }
    }
    
    // Generate share URL
    function generateShareUrl(coefficients) {
      const encoded = encodeDataToBase64(coefficients);
      const baseUrl = window.location.origin + window.location.pathname;
      return baseUrl + '?d=' + encodeURIComponent(encoded);
    }
    
    // Load data from URL params
    function loadFromUrlParams() {
      const urlParams = new URLSearchParams(window.location.search);
      const dataParam = urlParams.get('d');
      
      if (dataParam) {
        try {
          const decoded = decodeDataFromBase64(decodeURIComponent(dataParam));
          if (decoded && decoded.d && decoded.n && decoded.k) {
            return decoded;
          }
        } catch (e) {
          console.error('Failed to load data from URL:', e);
        }
      }
      return null;
    }
    
    // Generate QR code and render to canvas
    function generateQRCode(url, targetCanvas, cellSize) {
      try {
        const qr = qrcode(0, 'L'); // Auto version, low error correction
        qr.addData(url);
        qr.make();
        
        const ctx = targetCanvas.getContext('2d');
        const moduleCount = qr.getModuleCount();
        const margin = cellSize * 2;
        const size = moduleCount * cellSize + margin * 2;
        
        targetCanvas.width = size;
        targetCanvas.height = size;
        
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, size, size);
        
        for (let row = 0; row < moduleCount; row++) {
          for (let col = 0; col < moduleCount; col++) {
            ctx.fillStyle = qr.isDark(row, col) ? '#000000' : '#ffffff';
            ctx.fillRect(
              col * cellSize + margin,
              row * cellSize + margin,
              cellSize,
              cellSize
            );
          }
        }
        
        return { width: size, height: size };
      } catch (e) {
        console.error('QR code generation failed:', e);
        return null;
      }
    }
    
    // Current coefficient data (for sharing)
    let currentCoefficients = null;

    // ============================================
    // UI
    // ============================================
    
    const canvas = document.getElementById('drawCanvas');
    const ctx = canvas.getContext('2d');
    let drawing = false;
    
    let currentStroke = [];
    let strokes = [];
    
    let multiStrokeMode = true;

    const reconCanvas = document.getElementById('reconCanvas');
    const rctx = reconCanvas.getContext('2d');
    
    let animationFrames = [];
    let currentFrameIndex = 0;
    let isPlaying = false;
    let animationId = null;

    function initCanvas(context, canvasElement) {
      context.fillStyle = 'white';
      context.fillRect(0, 0, canvasElement.width, canvasElement.height);
    }

    function updateStatus(text) {
      document.getElementById('statusText').textContent = text;
    }

    function showProgress(show) {
      document.getElementById('progressContainer').style.display = show ? 'block' : 'none';
    }

    function setProgress(percent) {
      document.getElementById('progressBar').style.width = percent + '%';
    }

    function redrawInputCanvas() {
      initCanvas(ctx, canvas);
      
      for (const stroke of strokes) {
        if (stroke.length > 0) {
          ctx.beginPath();
          ctx.moveTo(stroke[0][0], stroke[0][1]);
          for (let i = 1; i < stroke.length; i++) {
            ctx.lineTo(stroke[i][0], stroke[i][1]);
          }
          ctx.strokeStyle = 'black';
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      }
      
      if (currentStroke.length > 0) {
        ctx.beginPath();
        ctx.moveTo(currentStroke[0][0], currentStroke[0][1]);
        for (let i = 1; i < currentStroke.length; i++) {
          ctx.lineTo(currentStroke[i][0], currentStroke[i][1]);
        }
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }

    function generatePoints3d() {
      const allStrokes = [...strokes];
      if (currentStroke.length > 0) {
        allStrokes.push(currentStroke);
      }
      
      if (allStrokes.length === 0) return [];
      
      const result = [];
      
      for (let s = 0; s < allStrokes.length; s++) {
        const stroke = allStrokes[s];
        
        if (s > 0 && result.length > 0 && stroke.length > 0) {
          const lastPoint = result[result.length - 1];
          const firstPoint = stroke[0];
          
          const numInterp = 10;
          for (let i = 1; i <= numInterp; i++) {
            const t = i / numInterp;
            const x = lastPoint[0] + (firstPoint[0] - lastPoint[0]) * t;
            const y = lastPoint[1] + (firstPoint[1] - lastPoint[1]) * t;
            result.push([x, y, 0]);
          }
        }
        
        for (const pt of stroke) {
          result.push([pt[0], pt[1], 1]);
        }
      }
      
      if (result.length > 0) {
        const lastPoint = result[result.length - 1];
        const firstPoint = result[0];
        
        const numInterp = 10;
        for (let i = 1; i <= numInterp; i++) {
          const t = i / numInterp;
          const x = lastPoint[0] + (firstPoint[0] - lastPoint[0]) * t;
          const y = lastPoint[1] + (firstPoint[1] - lastPoint[1]) * t;
          result.push([x, y, 0]);
        }
      }
      
      return result;
    }

    function generatePoints2d() {
      const allStrokes = [...strokes];
      if (currentStroke.length > 0) {
        allStrokes.push(currentStroke);
      }
      
      const result = [];
      for (const stroke of allStrokes) {
        for (const pt of stroke) {
          result.push([pt[0], pt[1]]);
        }
      }
      return result;
    }

    initCanvas(ctx, canvas);
    initCanvas(rctx, reconCanvas);

    document.getElementById('multiStrokeMode').addEventListener('change', (e) => {
      multiStrokeMode = e.target.checked;
      const modeInfo = document.getElementById('modeInfo');
      if (multiStrokeMode) {
        modeInfo.textContent = 'Multi-stroke Mode: Draw multiple lines. Gaps between strokes appear faded.';
      } else {
        modeInfo.textContent = 'Single-stroke Mode: Canvas resets on each new stroke';
      }
    });

    canvas.addEventListener('mousedown', (e) => {
      drawing = true;
      
      if (!multiStrokeMode) {
        strokes = [];
        currentStroke = [];
        initCanvas(ctx, canvas);
      }
      
      currentStroke = [];
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top) * scaleY;
      currentStroke.push([x, y]);
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 2;
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!drawing) return;
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top) * scaleY;
      currentStroke.push([x, y]);
      ctx.lineTo(x, y);
      ctx.stroke();
    });

    canvas.addEventListener('mouseup', () => {
      if (drawing && currentStroke.length > 0) {
        strokes.push([...currentStroke]);
        currentStroke = [];
      }
      drawing = false;
    });

    canvas.addEventListener('mouseleave', () => {
      if (drawing && currentStroke.length > 0) {
        strokes.push([...currentStroke]);
        currentStroke = [];
      }
      drawing = false;
    });

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      drawing = true;
      
      if (!multiStrokeMode) {
        strokes = [];
        currentStroke = [];
        initCanvas(ctx, canvas);
      }
      
      currentStroke = [];
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const touch = e.touches[0];
      const x = (touch.clientX - rect.left) * scaleX;
      const y = (touch.clientY - rect.top) * scaleY;
      currentStroke.push([x, y]);
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.strokeStyle = 'black';
      ctx.lineWidth = 2;
    });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (!drawing) return;
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const touch = e.touches[0];
      const x = (touch.clientX - rect.left) * scaleX;
      const y = (touch.clientY - rect.top) * scaleY;
      currentStroke.push([x, y]);
      ctx.lineTo(x, y);
      ctx.stroke();
    });

    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      if (drawing && currentStroke.length > 0) {
        strokes.push([...currentStroke]);
        currentStroke = [];
      }
      drawing = false;
    });

    const PEN_THRESHOLD = 0.5;
    
    function drawPoints3d(context, canvasEl, pts) {
      initCanvas(context, canvasEl);
      if (pts.length < 2) return;
      
      for (let i = 1; i < pts.length; i++) {
        const x0 = pts[i-1][0];
        const y0 = pts[i-1][1];
        const pen0 = pts[i-1][2];
        const x1 = pts[i][0];
        const y1 = pts[i][1];
        const pen1 = pts[i][2];
        
        const penAvg = (pen0 + pen1) / 2;
        
        if (penAvg < PEN_THRESHOLD) continue;
        
        const alpha = (penAvg - PEN_THRESHOLD) / (1 - PEN_THRESHOLD);
        
        context.beginPath();
        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.strokeStyle = `rgba(255, 0, 0, ${alpha})`;
        context.lineWidth = 2;
        context.stroke();
      }
    }

    function drawPoints2d(context, canvasEl, pts, color = 'red') {
      initCanvas(context, canvasEl);
      if (pts.length > 0) {
        context.beginPath();
        context.moveTo(pts[0][0], pts[0][1]);
        for (let i = 1; i < pts.length; i++) {
          context.lineTo(pts[i][0], pts[i][1]);
        }
        context.strokeStyle = color;
        context.lineWidth = 2;
        context.stroke();
      }
    }

    function drawPoints(context, canvasEl, pts) {
      if (pts.length === 0) return;
      
      if (pts[0].length === 3) {
        drawPoints3d(context, canvasEl, pts);
      } else {
        drawPoints2d(context, canvasEl, pts);
      }
    }

    document.getElementById('clearBtn').addEventListener('click', () => {
      strokes = [];
      currentStroke = [];
      animationFrames = [];
      if (animationId) {
        cancelAnimationFrame(animationId);
        clearTimeout(animationId);
        animationId = null;
      }
      isPlaying = false;
      initCanvas(ctx, canvas);
      initCanvas(rctx, reconCanvas);
      document.getElementById('downloadVideoBtn').disabled = true;
      updateStatus('Draw something and click Transform');
    });

    document.getElementById('processBtn').addEventListener('click', () => {
      if (animationId) {
        cancelAnimationFrame(animationId);
        clearTimeout(animationId);
        animationId = null;
      }
      isPlaying = false;
      showProgress(false);
      
      const points2d = generatePoints2d();
      const points3d = generatePoints3d();
      
      if (points2d.length === 0) {
        alert("Please draw something on the canvas first");
        return;
      }
      
      const K = parseInt(document.getElementById('kValue').value);
      if (isNaN(K) || K < 1) {
        alert("K must be a positive integer");
        return;
      }

      updateStatus('Processing...');
      
      const useMultiStroke = multiStrokeMode;
      const inputPoints = useMultiStroke ? points3d : points2d;
      
      setTimeout(() => {
        try {
          let result;
          if (useMultiStroke) {
            result = reconstructFourier3d(inputPoints, K);
          } else {
            result = reconstructFourier2d(inputPoints, K);
          }
          
          drawPoints(rctx, reconCanvas, result);
          const strokeInfo = useMultiStroke ? `, Strokes: ${strokes.length}` : '';
          updateStatus(`Transform complete (K=${K}, Points: ${inputPoints.length}${strokeInfo})`);
        } catch (error) {
          console.error("Error:", error);
          alert("An error occurred: " + error.message);
          updateStatus('Error occurred');
        }
      }, 10);
    });

    document.getElementById('animationBtn').addEventListener('click', () => {
      const points2d = generatePoints2d();
      const points3d = generatePoints3d();
      
      if (points2d.length === 0) {
        alert("Please draw something on the canvas first");
        return;
      }
      
      const numFrames = parseInt(document.getElementById('numFrames').value);
      if (isNaN(numFrames) || numFrames < 5) {
        alert("Frame count must be at least 5");
        return;
      }

      if (animationId) {
        cancelAnimationFrame(animationId);
        clearTimeout(animationId);
        animationId = null;
      }

      updateStatus('Generating animation...');
      showProgress(true);
      setProgress(0);

      const useMultiStroke = multiStrokeMode;
      const inputPoints = useMultiStroke ? points3d : points2d;

      setTimeout(() => {
        try {
          animationFrames = generateAnimationFrames(inputPoints, numFrames, useMultiStroke);
          
          if (animationFrames.length === 0) {
            updateStatus('No animation data');
            showProgress(false);
            return;
          }
          
          currentFrameIndex = 0;
          isPlaying = true;
          document.getElementById('downloadVideoBtn').disabled = false;
          
          updateStatus(`Playing animation (${animationFrames.length} frames)`);
          
          playAnimation();
          
        } catch (error) {
          console.error("Error:", error);
          alert("An error occurred: " + error.message);
          updateStatus('Error occurred');
          showProgress(false);
        }
      }, 10);
    });

    function playAnimation() {
      if (!isPlaying || animationFrames.length === 0) return;
      
      const frame = animationFrames[currentFrameIndex];
      drawPoints(rctx, reconCanvas, frame.points);
      
      const progress = ((currentFrameIndex + 1) / animationFrames.length) * 100;
      setProgress(progress);
      
      if (frame.isFinal) {
        updateStatus(`Complete! K = ${frame.K} (all components)`);
      } else {
        updateStatus(`K = ${frame.K} (Frame ${currentFrameIndex + 1}/${animationFrames.length})`);
      }
      
      currentFrameIndex++;
      if (currentFrameIndex >= animationFrames.length) {
        currentFrameIndex = 0;
      }
      
      const delay = frame.isFinal ? 3000 : 100;
      
      animationId = setTimeout(() => {
        requestAnimationFrame(playAnimation);
      }, delay);
    }

    document.getElementById('downloadVideoBtn').addEventListener('click', async () => {
      if (animationFrames.length === 0) {
        alert("Please generate an animation first");
        return;
      }

      isPlaying = false;
      if (animationId) {
        cancelAnimationFrame(animationId);
        clearTimeout(animationId);
        animationId = null;
      }

      updateStatus('Generating video...');
      showProgress(true);
      setProgress(0);

      try {
        const stream = reconCanvas.captureStream(30);
        const mediaRecorder = new MediaRecorder(stream, {
          mimeType: 'video/webm;codecs=vp9',
          videoBitsPerSecond: 5000000
        });
        
        const chunks = [];
        mediaRecorder.ondataavailable = (e) => {
          if (e.data.size > 0) {
            chunks.push(e.data);
          }
        };
        
        mediaRecorder.onstop = () => {
          const blob = new Blob(chunks, { type: 'video/webm' });
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = 'fourier_animation.webm';
          link.click();
          URL.revokeObjectURL(url);
          
          updateStatus('Video download complete');
          showProgress(false);
          
          isPlaying = true;
          playAnimation();
        };

        mediaRecorder.start();
        
        for (let i = 0; i < animationFrames.length; i++) {
          const frame = animationFrames[i];
          drawPoints(rctx, reconCanvas, frame.points);
          setProgress(((i + 1) / animationFrames.length) * 100);
          
          const delay = frame.isFinal ? 3000 : 100;
          await new Promise(resolve => setTimeout(resolve, delay));
        }
        
        mediaRecorder.stop();
        
      } catch (error) {
        console.error("Error:", error);
        
        alert("Error generating video. Your browser may not support WebM format.");
        updateStatus('Video generation failed');
        showProgress(false);
        
        isPlaying = true;
        playAnimation();
      }
    });

    document.getElementById('downloadInputBtn').addEventListener('click', () => {
      const link = document.createElement('a');
      link.download = 'input_image.png';
      link.href = canvas.toDataURL('image/png');
      link.click();
    });

    document.getElementById('downloadOutputBtn').addEventListener('click', () => {
      const link = document.createElement('a');
      link.download = 'fourier_image.png';
      link.href = reconCanvas.toDataURL('image/png');
      link.click();
    });

    // ============================================
    // QR Card Generation & Sharing
    // ============================================
    
    const shareModal = document.getElementById('shareModal');
    const cardCanvas = document.getElementById('cardCanvas');
    const cardCtx = cardCanvas.getContext('2d');
    let currentShareUrl = '';
    
    // Generate artifact card image
    function generateArtifactCard(artCanvas, coefficients) {
      const shareUrl = generateShareUrl(coefficients);
      currentShareUrl = shareUrl;
      
      // Card size settings
      const cardWidth = 800;
      const cardHeight = 1000;
      const margin = 30;
      const artSize = 500;
      const qrSize = 180;
      
      cardCanvas.width = cardWidth;
      cardCanvas.height = cardHeight;
      
      // Background
      cardCtx.fillStyle = '#ffffff';
      cardCtx.fillRect(0, 0, cardWidth, cardHeight);
      
      // Title
      cardCtx.fillStyle = '#333333';
      cardCtx.font = 'bold 24px Arial, sans-serif';
      cardCtx.textAlign = 'center';
      cardCtx.fillText('Fourier Art Artifact', cardWidth / 2, margin + 25);
      
      // Place art image in center
      const artX = (cardWidth - artSize) / 2;
      const artY = margin + 50;
      
      // Border
      cardCtx.strokeStyle = '#333333';
      cardCtx.lineWidth = 2;
      cardCtx.strokeRect(artX - 2, artY - 2, artSize + 4, artSize * (artCanvas.height / artCanvas.width) + 4);
      
      // Draw art image
      const artHeight = artSize * (artCanvas.height / artCanvas.width);
      cardCtx.drawImage(artCanvas, artX, artY, artSize, artHeight);
      
      // Generate QR code
      const tempQrCanvas = document.createElement('canvas');
      const qrResult = generateQRCode(shareUrl, tempQrCanvas, 4);
      
      if (qrResult) {
        // Place QR code at bottom right
        const qrX = cardWidth - margin - qrSize;
        const qrY = artY + artHeight + 30;
        cardCtx.drawImage(tempQrCanvas, qrX, qrY, qrSize, qrSize);
        
        // QR label
        cardCtx.fillStyle = '#666666';
        cardCtx.font = '12px Arial, sans-serif';
        cardCtx.textAlign = 'center';
        cardCtx.fillText('Scan to restore', qrX + qrSize / 2, qrY + qrSize + 15);
      }
      
      // Rosetta Text (formula info for restoration)
      const rosettaY = artY + artHeight + 50;
      const rosettaX = margin;
      
      cardCtx.fillStyle = '#333333';
      cardCtx.font = 'bold 14px monospace';
      cardCtx.textAlign = 'left';
      cardCtx.fillText('=== ROSETTA STONE FOR FUTURE ===', rosettaX, rosettaY);
      
      cardCtx.font = '12px monospace';
      cardCtx.fillStyle = '#555555';
      
      const rosettaLines = [
        'Format: IDFT (Real part only) of X, Y, Pen',
        'Formula: v(t) = (1/N) * Î£ Re(Fk * exp(i*2*Ï€*k*t))',
        '',
        'Data structure: { n: N, k: [indices], d: [coeffs] }',
        '  - N: Original point count',
        '  - k: Selected frequency indices (sorted by amplitude)',
        '  - d: [X coeffs, Y coeffs, Pen coeffs]',
        '       Each: [Re0, Im0, Re1, Im1, ...]',
        '',
        'To reconstruct:',
        '  1. Decode Base64 from URL parameter "d"',
        '  2. Parse JSON to get {n, k, d}',
        '  3. For t âˆˆ [0,1), compute:',
        '     x(t) = Î£ Re(Fxk * exp(i*2*Ï€*fk*N*t)) / N',
        '     y(t) = Î£ Re(Fyk * exp(i*2*Ï€*fk*N*t)) / N',
        '     pen(t) = clamp(Î£ Re(Fpenk * ...) / N, 0, 1)',
        '  4. Draw line when pen(t) > 0.5',
        '',
        `K = ${coefficients.k.length}, N = ${coefficients.n}`
      ];
      
      let lineY = rosettaY + 20;
      for (const line of rosettaLines) {
        cardCtx.fillText(line, rosettaX, lineY);
        lineY += 16;
      }
      
      // Footer
      cardCtx.fillStyle = '#888888';
      cardCtx.font = '10px Arial, sans-serif';
      cardCtx.textAlign = 'center';
      cardCtx.fillText('Generated by FourierPicture | github.com/milky1210/FourierPicture', cardWidth / 2, cardHeight - 15);
      cardCtx.fillText(`Created: ${new Date().toISOString().split('T')[0]}`, cardWidth / 2, cardHeight - 30);
      
      return shareUrl;
    }
    
    // Create QR Card button
    document.getElementById('shareBtn').addEventListener('click', () => {
      if (!currentCoefficients) {
        alert('Please run the Fourier transform first');
        return;
      }
      
      generateArtifactCard(reconCanvas, currentCoefficients);
      shareModal.style.display = 'flex';
    });
    
    // Download card
    document.getElementById('downloadCardBtn').addEventListener('click', () => {
      const link = document.createElement('a');
      link.download = 'fourier_artifact_card.png';
      link.href = cardCanvas.toDataURL('image/png');
      link.click();
    });
    
    // Copy URL
    document.getElementById('copyUrlBtn').addEventListener('click', async () => {
      if (currentShareUrl) {
        try {
          await navigator.clipboard.writeText(currentShareUrl);
          alert('URL copied to clipboard');
        } catch (e) {
          // Fallback
          const textArea = document.createElement('textarea');
          textArea.value = currentShareUrl;
          document.body.appendChild(textArea);
          textArea.select();
          document.execCommand('copy');
          document.body.removeChild(textArea);
          alert('URL copied to clipboard');
        }
      }
    });
    
    // Close modal
    document.getElementById('closeModalBtn').addEventListener('click', () => {
      shareModal.style.display = 'none';
    });
    
    // Close modal on outside click
    shareModal.addEventListener('click', (e) => {
      if (e.target === shareModal) {
        shareModal.style.display = 'none';
      }
    });
    
    // ============================================
    // URL Parameter Restoration (Viewer Mode)
    // ============================================
    
    // Generate animation frames from shared data
    function generateAnimationFramesFromCoefficients(data, numFrames) {
      const K = data.k.length;
      const is3d = data.d.length === 3;
      
      if (K === 0) return [];
      if (K < 2) {
        const points = reconstructFromCoefficients(data);
        return [{ K: K, points: points, isFinal: true }];
      }
      
      const kMin = 2;
      const kMax = K;
      
      const kValuesSet = new Set();
      for (let i = 0; i < numFrames; i++) {
        let k;
        if (numFrames === 1) {
          k = kMax;
        } else {
          const t = i / (numFrames - 1);
          const tAdjusted = Math.pow(t, 0.6);
          const logK = Math.log(kMin) + (Math.log(kMax) - Math.log(kMin)) * tAdjusted;
          k = Math.round(Math.exp(logK));
        }
        k = Math.max(kMin, Math.min(k, kMax));
        kValuesSet.add(k);
      }
      
      const kValues = Array.from(kValuesSet).sort((a, b) => a - b);
      
      const frames = [];
      for (const k of kValues) {
        // Use only k coefficients
        const partialData = {
          f: data.f,
          n: data.n,
          k: data.k.slice(0, k),
          d: data.d.map(arr => arr.slice(0, k * 2))
        };
        const reconstructed = reconstructFromCoefficients(partialData);
        frames.push({
          K: k,
          points: reconstructed,
          isFinal: false
        });
      }
      
      // Final frame (all coefficients)
      const finalPoints = reconstructFromCoefficients(data);
      frames.push({
        K: K,
        points: finalPoints,
        isFinal: true
      });
      
      return frames;
    }
    
    // Initialize viewer mode
    function initViewerMode(data) {
      const is3d = data.d.length === 3;
      
      // Hide left panel, expand right panel
      document.querySelector('.left-panel').style.display = 'none';
      document.querySelector('.right-panel').style.flex = '1';
      document.querySelector('.right-panel .panel-title').textContent = 'Shared Fourier Art';
      
      // Change button visibility
      document.getElementById('shareBtn').style.display = 'none';
      
      // Add new buttons
      const buttonGroup = document.querySelector('.right-panel .button-group');
      
      // Animation play button
      const playBtn = document.createElement('button');
      playBtn.id = 'viewerPlayBtn';
      playBtn.className = 'animation';
      playBtn.textContent = 'Play Animation';
      buttonGroup.appendChild(playBtn);
      
      // Video download button
      const videoBtn = document.createElement('button');
      videoBtn.id = 'viewerVideoBtn';
      videoBtn.className = 'animation';
      videoBtn.textContent = 'Download Video';
      videoBtn.disabled = true;
      buttonGroup.appendChild(videoBtn);
      
      // New creation link
      const newBtn = document.createElement('button');
      newBtn.className = 'secondary';
      newBtn.textContent = 'Create New';
      newBtn.addEventListener('click', () => {
        window.location.href = window.location.pathname;
      });
      buttonGroup.appendChild(newBtn);
      
      // Initial drawing
      const points = reconstructFromCoefficients(data);
      drawPoints(rctx, reconCanvas, points);
      updateStatus(`Restored (K=${data.k.length}, N=${data.n})`);
      
      // Save coefficient data (viewer mode - not used for sharing)
      currentCoefficients = data;
      
      // Animation play
      playBtn.addEventListener('click', () => {
        if (animationId) {
          cancelAnimationFrame(animationId);
          clearTimeout(animationId);
          animationId = null;
        }
        
        animationFrames = generateAnimationFramesFromCoefficients(data, 30);
        
        if (animationFrames.length === 0) {
          updateStatus('No animation data');
          return;
        }
        
        currentFrameIndex = 0;
        isPlaying = true;
        videoBtn.disabled = false;
        
        showProgress(true);
        updateStatus(`Playing animation (${animationFrames.length} frames)`);
        playAnimation();
      });
      
      // Video download
      videoBtn.addEventListener('click', async () => {
        if (animationFrames.length === 0) {
          // Generate if not yet generated
          animationFrames = generateAnimationFramesFromCoefficients(data, 30);
        }
        
        if (animationFrames.length === 0) {
          alert('No animation data');
          return;
        }
        
        isPlaying = false;
        if (animationId) {
          cancelAnimationFrame(animationId);
          clearTimeout(animationId);
          animationId = null;
        }
        
        updateStatus('Generating video...');
        showProgress(true);
        setProgress(0);
        
        try {
          const stream = reconCanvas.captureStream(30);
          const mediaRecorder = new MediaRecorder(stream, {
            mimeType: 'video/webm;codecs=vp9',
            videoBitsPerSecond: 5000000
          });
          
          const chunks = [];
          mediaRecorder.ondataavailable = (e) => {
            if (e.data.size > 0) {
              chunks.push(e.data);
            }
          };
          
          mediaRecorder.onstop = () => {
            const blob = new Blob(chunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'fourier_animation.webm';
            link.click();
            URL.revokeObjectURL(url);
            
            updateStatus('Video download complete');
            showProgress(false);
            
            // Show final frame
            const finalPoints = reconstructFromCoefficients(data);
            drawPoints(rctx, reconCanvas, finalPoints);
          };
          
          mediaRecorder.start();
          
          for (let i = 0; i < animationFrames.length; i++) {
            const frame = animationFrames[i];
            drawPoints(rctx, reconCanvas, frame.points);
            setProgress(((i + 1) / animationFrames.length) * 100);
            
            const delay = frame.isFinal ? 3000 : 100;
            await new Promise(resolve => setTimeout(resolve, delay));
          }
          
          mediaRecorder.stop();
          
        } catch (error) {
          console.error("Error:", error);
          alert("Error generating video. Your browser may not support WebM format.");
          updateStatus('Video generation failed');
          showProgress(false);
        }
      });
    }
    
    // ============================================
    // Initialization
    // ============================================
    
    // Check URL params on page load
    window.addEventListener('load', () => {
      const sharedData = loadFromUrlParams();
      
      if (sharedData) {
        // Start in viewer mode
        initViewerMode(sharedData);
      } else {
        // Normal mode - share button enabled after transform
        document.getElementById('shareBtn').disabled = true;
      }
    });
    
    // Save coefficients on Fourier transform
    document.getElementById('processBtn').addEventListener('click', () => {
      // Calculate coefficients after transform
      setTimeout(() => {
        const points3d = generatePoints3d();
        const points2d = generatePoints2d();
        
        if (points2d.length > 0) {
          const K = parseInt(document.getElementById('kValue').value);
          const useMultiStroke = multiStrokeMode;
          const inputPoints = useMultiStroke ? points3d : points2d;
          
          // Get coefficients for sharing (limited to K, max 50)
          const shareK = Math.min(K, 50);
          currentCoefficients = getFourierCoefficients(inputPoints, shareK, useMultiStroke);
          
          // Enable share button
          document.getElementById('shareBtn').disabled = false;
        }
      }, 100);
    });
  </script>
</body>
</html>
